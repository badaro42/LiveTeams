// **************************************
// constantes
var SMARTHPHONE_MAX_WIDTH = 600;
var entity_types = {
  circle: "Círculo",
  rectangle: "Rectângulo",
  point: "Ponto",
  polygon: "Polígono",
  linestring: "Linha Poligonal"
};
var object_type = {
  team: "Equipa",
  geo_entity: "Geo-entidade"
};
var actions = {
  update: "atualizada",
  remove: "removida",
  create: "criada"
};


// **************************************
// objectos
function HistoryEntry(o_type, o_id, time, event, watch) {
  this.obj_type = o_type; // o tipo do objecto
  this.obj_id = o_id; // o id do objecto
  this.timestamp = time; // a data em que ocorreu a ação
  this.action = event; // o evento que ocorreu
  this.watched = watch; // indica se a entrada atual ja foi vista pelo utilizador
}
// override do metodo 'equals' para comparar os campos que queremos nas entradas do historico
// ver comentario do metodo 'containsHistoryEntry' para uma melhor explicação
HistoryEntry.prototype.equals = function (o) {
  var time_diff = Math.abs(o.timestamp - this.timestamp);
  return this.obj_type === o.obj_type && this.action === o.action && this.obj_id === o.obj_id &&
      (time_diff < 20000);
};


// **************************************
// variaveis da mais variada especie :)
var map, osmUrl, osmAttrib, osm, sidebar, cluster;
var drawnItems;
var e_type, e_radius, e_coords, coords_to_display, e_length, e_area, e_layer, e_num_points;

var is_sse_update = false;

// cada entrada é da forma {id: feature_id, type: tipo (em portugues),
// latlon: array com objetos L.latLng), layer: o objeto que esta no mapa}
var all_geo_entities;
var all_teams; // cada entrada é da forma {id: feature_id, marker: L.marker(L.latLng(lat, lng))}
var teams_to_remove = [];
var source;

var previous_user_location; // {timestamp: Date(), position: L.latLng(lat, lng)}
var no_sleep_enabled = false;
var is_modal_open = false;


// variaveis relacionadas a informação guardada no browser - localStorage
var curr_user_saved_prefs = { // local storage - objeto com as preferencias do utilizador!
  show_navbar: null, // o estado de visibilidade da navbar na pagina inicial
  events_history: [], // array com todas as entradas do historico
  max_zoom: 16 // valor default: se houver valor no localStorage, substitui este
};
var last_window_height;


// var incrementada quando um dos conjuntos de dados é carregado - equipas e entidades
var geo_data_loaded = 0;

var team_icon = L.icon({
  iconUrl: '/assets/team_icon.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});

var user_pos_icon = L.icon({
  iconUrl: '/assets/user-64.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});


$(document).ready(function () {
  // inicialização da dropdown da barra de navegação
  $('.dropdown-button').dropdown({
        inDuration: 300,
        outDuration: 225,
        constrain_width: true, // Does not change width of dropdown to that of the activator
        hover: true, // Activate on hover
        gutter: 0, // Spacing from edge
        belowOrigin: true, // Displays dropdown below the button
        alignment: 'left' // Displays dropdown with edge aligned to the left of button
      }
  );

  // inicialização da barra de navegação lateral
  $(".button-collapse").sideNav();

  // remove as notificações da sidebar quando o utilizador fecha a sidebar apenas quando a tab aberta era
  // a do historico de eventos
  $('#history-tab-icon').on('click', function (e) {
    console.log(e.currentTarget);
    var parent = $(e.currentTarget).parent();

    // remove o indicador de notificações novas, coloca todas as entradas como vistas e grava-as no localStorage
    if (!parent.hasClass('active')) {
      $.each(curr_user_saved_prefs.events_history, function (index, elem) {
        elem.watched = true;
      });
      localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));

      if ($(e.currentTarget).attr('data-badge') !== undefined) {
        console.log("ha pelo menos uma entrada nova, vamos limpar as notificaçoes e remover as classes");
        setTimeout(function () {
          $(e.currentTarget).attr('data-badge', null);
          $('.timeline-item div').removeClass("new-entry-content new-entry-icon");
          $('.timeline-content h6').removeClass("new-entry-header");
        }, 10000);
      }
    }
  });

  // verifica as preferencias do utilizador no objeto localStorage
  last_window_height = window.innerHeight;
  checkUserPreferences();

  // chama a função para atualizar as timestamps da entradas
  // esta função é executada a cada 30 segundos
  setTimeout(updateTimestamps, 30000);

  // listener que é executado quando a janela é redimensionada
  window.onresize = onWindowResize;

  // listener para quando o utilizador carrega na checkbox para mostrar/esconder a navbar
  $('#homepage-toggle-navbar').on('change', function () {
    if ($(this).is(':checked'))
      toggleNavBar(true);
    else
      toggleNavBar(false);
  });

  // seleciona todas as equipas no modal para criar entidade
  $('#select_all_teams').on('click', function () {
    console.log("select_all_teams clique");
    $('#select_team_ids option').prop('selected', true);
  });

  // remove a selecção de todas as equipas no modal para criar entidade
  $('#select_no_teams').on('click', function () {
    console.log("select_no_teams clique");
    $('#select_team_ids option').prop('selected', false);
  });

  $('#button-da-merda').on('click', function () {
    console.log("CARREGUEI NO BOTAO!!! HEHE");
    $('#modal_entity_coordinates').openModal();
  });

  // apenas permite numeros no campo do numero de telefone
  $(".numeric").numeric();

  // listener para quando o valor do slider nas opções é alterado
  $('#range_max_zoom').on('change', function () {
    console.log("slider max zoom!!!");
    curr_user_saved_prefs.max_zoom = $(this).val();
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
  });

  // apenas ativa a cena do wake lock caso seja um dispositivo movel
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.
      test(navigator.userAgent)) {
    // Take the user to a different screen here.
//    alert("Dispositivo Móvel.");

    var noSleep = new NoSleep();

    var obj = document.getElementById('map');
    obj.addEventListener('touchstart', function () {
      if (!no_sleep_enabled) {
        console.log("NoSleep Ativado :)");
        noSleep.enable(); // keep the screen on!
        no_sleep_enabled = true;
      }
    }, false);
  }
  else {
//    alert("Dispositivo Fixo.");
  }

  all_teams = [];
  all_geo_entities = [];

  // delay da inicialização do eventSource
  // delay atual - 10 segundos
  setTimeout(eventSourceSetup, 10000);

  sidebar = L.control.sidebar('sidebar', {position: 'right'}).addTo(map);
  cluster = L.markerClusterGroup();

  osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  osm = L.tileLayer(osmUrl, {maxZoom: 19});

  /* mapa principal */
  map = L.map("map", {
    zoom: 12,
    center: [38.627881, -9.161007],
    layers: [osm],
    zoomControl: true,
    attributionControl: false
  });

  // ativa a geolocalização apenas se o browser a suportar
  if ("geolocation" in navigator) { /* geolocation is available */
    new L.control.locate({
      position: "topleft",
      layer: drawnItems,
      drawCircle: true,
      follow: false,
      setView: false,
      keepCurrentZoomLevel: true,
      stopFollowingOnDrag: false,
      remainActive: false,
      markerStyle: {
        weight: 1,
        opacity: 0.8,
        fillOpacity: 0.8
      },
      circleStyle: {
        weight: 1,
        clickable: false
      },
      icon: "fa fa-location-arrow",
      metric: true,
      strings: {
        title: "Clique aqui para ativar/desativar a geolocalização",
        popup: "A sua localização atual está dentro deste círculo com {distance} metros.",
        outsideMapBoundsMsg: "Parece que se encontra fora dos limites do mapa"
      },
      locateOptions: {
        maxZoom: 19,
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 15000,
        timeout: 1000
      }
    }).addTo(map);

    map.on('locationfound', function (e) {
      console.log("POSIÇÃO OBTIDA COM SUCESSO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
      console.log(e);

      var distance = -1, time_spanned = -1, curr_time, prev_time;
      if (typeof previous_user_location !== 'undefined') {
        distance = previous_user_location.position.distanceTo(e.latlng);
        curr_time = new Date();
        prev_time = previous_user_location.timestamp;

        // caso a diferença seja seja, passa a 1ms para evitar divisão por zero
        // resultado em ms, divisao por 1000 para converter para segundos
        time_spanned = (curr_time - prev_time) == 0 ? 1 : (curr_time - prev_time) / 1000;

        console.log("DIFERENÇA DO TIMESTAMP: " + time_spanned);
        console.log("DISTANCIA PARA MEDIÇÃO ANTERIOR: " + distance);
      }

      // envia a nova posição para o servidor caso seja a primeira vez,
      // a distancia para a posição anterior seja superior a 10 metros ou
      // a ultima medição tenha sido há mais de 10 segundos
      if ((distance == -1 || distance > 10) && (time_spanned == -1 || time_spanned > 10)) {
        console.log("POSIÇÃO A MAIS DE 10METROS E HÁ MAIS DE 10SEGUNDOS!!!!!!");

        // atualizam-se ja estas variaveis pois o retorno do ajax pode demorar e aí a posição era
        // atualizada várias vezes ao invés de apenas uma.
        previous_user_location = {position: e.latlng, timestamp: e.timestamp};

        $.ajax({
          type: "POST",
          url: "/update_location",
          data: {
            latitude: e.latlng.lat,
            longitude: e.latlng.lng,
            user_id: gon.user_id
          },
          success: function (result) {
            console.log(result);

//            var new_marker = L.marker(e.latlng, {icon: user_pos_icon});
//            cluster.addLayer(new_marker);
//            map.addLayer(cluster);

            var d = new Date();
            var time = d.toLocaleTimeString();

            var li = $('<li/>').addClass('collection-item');
            var span1 = $('<span/>').text("Coordenadas: [" + e.latlng.lat + "; " + e.latlng.lng + "]");
            var span2 = $('<span/>').text("Precisão da medição: " + e.accuracy + " metros");
            var span3 = $('<span/>').text("Data do sistema: " + time);

            li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
            $('#current_position_list').prepend(li);
          },
          error: function (err) {
            console.log(err);
          }
        });
//      map.setView(c_latlng, 16);
      }
//      setTimeout(map.locate(), 5000);
    });

  }
  else { /* geolocation IS NOT available */
    noty({
      text: 'Este browser não suporta geolocalização!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  }


  drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  /* controlo do zoom do mapa  */
  map.zoomControl.setPosition('topleft');

  // cria a barra de controlos para a criaçao de entidades
  L.drawLocal.draw.toolbar.buttons.polygon = 'Desenhar um poligono';
  L.drawLocal.draw.toolbar.buttons.polyline = 'Desenhar uma linha poligonal';
  L.drawLocal.draw.toolbar.buttons.marker = 'Desenhar um marcador';
  L.drawLocal.draw.toolbar.buttons.rectangle = 'Desenhar um rectangulo';
  L.drawLocal.draw.toolbar.buttons.circle = 'Desenhar um circulo';
  var drawControl = new L.Control.Draw({
    position: 'bottomleft',
    draw: {
      polygon: {
        title: 'Pol�gono',
        allowIntersection: true,
        drawError: {
          color: '#b00b00',
          timeout: 1000
        },
        shapeOptions: {
          color: '#bada55'
        },
        showArea: true
      },
      polyline: {
        metric: false
      },
      circle: {
        shapeOptions: {
          color: '#662d91'
        }
      },
      //rectangle: false //� assim que se desativam op��es
    }
//    },
//    edit: {
//      featureGroup: drawnItems
//    }
  });
  map.addControl(drawControl);

  // cria uma imagem com a inicial do nome do utilizador autenticado
  $('.profile_name').initial({
    name: 'Name', // Name of the user
    charCount: 1, // Number of characherts to be shown in the picture.
    textColor: '#ffffff', // Color of the text
    seed: 0, // randomize background color
    height: 40,
    width: 40,
    fontSize: 20,
    fontWeight: 400,
    fontFamily: 'Helvetica Neue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial, Lucida Grande, sans-serif',
    radius: 25
  });

  //altera o background da lista das equipas quando o utilizador faz hover com o rato
  $("div.collapsible-header")
      .mouseenter(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#eaeaea")
      })
      .mouseleave(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#fff")
      });

  //faz mais ou menos o mesmo mas quando o utilizador clica numa entrada da lista
  $("div.collapsible-header").click(function (div) {
    $("div.collapsible-header").css("background", "#fff");
    $("div.collapsible-header.active").css("background", "#eaeaea");
  });

  // inicializa as dropdowns que existem na pagina!
  $('select').material_select();

  map.spin(true, {
    lines: 15, // The number of lines to draw
    length: 0, // The length of each line
    width: 11, // The line thickness
    radius: 40, // The radius of the inner circle
    scale: 0.5, // Scales overall size of the spinner
    corners: 1, // Corner roundness (0..1)
    color: '#000', // #rgb or #rrggbb or array of colors
    opacity: 0, // Opacity of the lines
    rotate: 0, // The rotation offset
    direction: 1, // 1: clockwise, -1: counterclockwise
    speed: 1.2, // Rounds per second
    trail: 60, // Afterglow percentage
    fps: 30, // Frames per second when using setTimeout() as a fallback for CSS
    zIndex: 2e9, // The z-index (defaults to 2000000000)
    className: 'spinner', // The CSS class to assign to the spinner
    top: '50%', // Top position relative to parent
    left: '50%', // Left position relative to parent
    shadow: false, // Whether to render a shadow
    hwaccel: true, // Whether to use hardware acceleration
    position: 'absolute' // Element positioning
  });

  // ****************** CHAMADAS ASSINCRONAS PARA POPULAR O MAPA ******************
  // retorna todas as entidades que estao na BD
  var geo_entities = new L.GeoJSON.AJAX("/geo_entities/geo_entities_to_json.json", {
    pointToLayer: geoPointToLayer,
    onEachFeature: onEachGeoEntity
  });

  var teams_json = new L.GeoJSON.AJAX("/teams/teams_to_json.json", {
    pointToLayer: teamPointToLayer,
    onEachFeature: onEachTeam
  });

  // listener invocado quando a chamada ajax das entidades terminar!
  geo_entities.on('data:loaded', function () {
    console.log("vector com os indices das geo_entities: " + all_geo_entities);
    console.log("finish");

    cluster.addLayer(geo_entities);
    map.addLayer(cluster);

    geo_data_loaded++;
    if (geo_data_loaded == 2) {
      map.spin(false);
      geo_data_loaded = 0;
    }

    noty({
      text: 'Entidades geográficas carregadas com sucesso!', timeout: 3500,
      type: 'success', layout: 'bottomCenter'
    });

    // caso haja parametro, centra o mapa na entidade enviada
    var entity_id = parseInt(getURLParameter('entity_id'));

    if (!isNaN(entity_id))
      centerMapOnGeoEntity(entity_id);
  });

  geo_entities.on('data:error', function (err) {
    console.log(err);
    noty({
      text: 'Erro a carregar as entidades geográficas do servidor!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  });

  // listener invocado quando a chamada ajax das equipas terminar!
  teams_json.on('data:loaded', function () {
    console.log("vector com os indices das equipas!!!!!:");
    console.log(all_teams);
    console.log("finish");

    cluster.addLayer(teams_json);
    map.addLayer(cluster);

    geo_data_loaded++;
    if (geo_data_loaded == 2) {
      map.spin(false);
      geo_data_loaded = 0;
    }

    noty({text: 'Equipas carregadas com sucesso!', timeout: 3500, type: 'success', layout: 'bottomCenter'});
  });

  teams_json.on('data:error', function (err) {
    console.log(err);
    noty({
      text: 'Erro a carregar as equipas do servidor!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  });


// ****************** LISTENERS PARA A CRIA��O/EDI��O DE ENTIDADES ******************

  /* listener invocado quando � criada uma feature */
  map.on('draw:created', function (e) {
    console.log(e);
    e_type = e.layerType;
    e_layer = e.layer;
    e_num_points = 1;

    var select = $('#select_team_ids');

    // vai obter todas as equipas para popular a select box
    // assim garante-se que as equipas para selecionar estão sempre de acordo com a base de dados!
    $.ajax({
      type: "GET",
      url: "/teams",
      dataType: "json",
      success: function (res) {
        // todas as equipas retornadas pelo servidor
        $.each(res, function (index, elem) {
          console.log(elem);

          var text = elem.name + " (ID: " + elem.id + ")";
          select.append($("<option/>", {
            value: elem.id,
            text: text
          }));
        });

        $('#select_team_ids_div label').addClass('active');
        console.log("final do each.");
      },
      error: function (res) {
        console.log("erro a popular as equipas: dropdown nova geo-entidade!!!");
        console.log(res);
      }
    });

    if (e_type === 'marker' || e_type === 'circle') {
      $("#e_area_div").prop('hidden', true);
      $("#e_length_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', true);

      if (e_type === 'circle') {
        e_radius = e_layer.getRadius();
        $('#e_type_div').removeClass('s4 s12').addClass('s6');
        $("#e_radius_div").prop('hidden', false);
        $('#e_radius').text(Math.round(e_radius));
        $('#e_type').text("Circulo");
      }
      else {
        e_radius = 0;
        $('#e_type_div').removeClass('s4 s6').addClass('s12');
        $("#e_radius_div").prop('hidden', true);
        $('#e_type').text("Marcador");
      }

      console.log(e_layer);
      e_coords = "POINT(" + e_layer.getLatLng().lng + " " + e_layer.getLatLng().lat + ")";
    }
    else if (e_type === 'polyline' || e_type === 'rectangle' || e_type === 'polygon') {
      e_radius = 0;
      e_num_points = e_layer.getLatLngs().length;

      $("#e_radius_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', false);
      $('#e_num_points').text(e_num_points);

      if (e_type === 'polyline') {
        e_coords = "LINESTRING(";

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_area_div").prop('hidden', true);
        $('#e_type').text("Linha Poligonal");
      }
      else {
        if (e_type === 'rectangle')
          $('#e_type').text("Rectangulo");
        else
          $('#e_type').text("Poligono");

        e_coords = "POLYGON((";
        e_area = L.GeometryUtil.geodesicArea(e_layer.getLatLngs());
        e_area = (Math.round(e_area) / 100000) + "";
        e_area = e_area.replace(".", ",");

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_length_div").prop('hidden', true);
        $("#e_area_div").prop('hidden', false);
        $('#e_area').text(e_area);
      }

      console.log(e_layer.getLatLngs());

      var temp_point = null;
      var c_arr = e_layer.getLatLngs();
      coords_to_display = "";
      e_length = 0;
      $.each(c_arr, function (i, curr_point) {
        coords_to_display += curr_point;
        if (e_type === 'polyline') {
          if (temp_point == null)
            temp_point = curr_point;
          else {
            e_length += temp_point.distanceTo(curr_point);
            temp_point = curr_point;
          }
        }
        e_coords += curr_point.lng + " " + curr_point.lat;
        if (i < c_arr.length - 1) {
          e_coords += ",";
          coords_to_display += "\n";
        }
      });

      $('#e_coords').val(coords_to_display);
      $('#e_coords').trigger('autoresize');
      $('#e_coords_div label').addClass('active');

      e_length = (Math.round(e_length) / 1000) + "";
      e_length = e_length.replace(".", ",");
      if (e_type === 'polyline') {
        e_coords += ")";
        $("#e_length_div").prop('hidden', false);
        $('#e_length').text(e_length);
      }
      else
        e_coords += "))";
    }

    // função executada quando a modal para inserir nova entidade é fechada
    var onModalHide = function () {
      is_modal_open = false;
    };

    $('#confirm_entity_creation').openModal({
      complete: onModalHide
    });

    is_modal_open = true;
  });

  /* listener invocado quando se edita uma feature */
//map.on('draw:edited', function (e) {
//    var layers = e.layers;
//    layers.eachLayer(function (layer) {
//        //do whatever you want, most likely save back to db
//    });
//});
});

// listeners para quando se carrega numa tecla predefinida.
$(document).keyup(function (e) {
  var elem, parent, tab_name, keyCode;
  keyCode = e.keyCode;

  // apenas queremos apanhar estas teclas quando a modal esta fechada, caso contrario
  // sempre que se introduzisse texto nas caixas de texto as abas laterais eram ativadas
  if (!is_modal_open) {
    // teclas que ativam a sidebar lateral
    if (keyCode == 69 || keyCode == 80 || keyCode == 85 || keyCode == 87 || keyCode == 83) {
      if (keyCode == 69) { // tecla 'E'
        elem = $('#teams-tab-icon');
        tab_name = 'teams';
      }
      else if (keyCode == 80) { // tecla 'P'
        elem = $('#profile-tab-icon');
        tab_name = 'profile';
      }
      else if (keyCode == 85) { // tecla 'U'
        elem = $('#users-tab-icon');
        tab_name = 'users';
      }
      else if (keyCode == 87) { // tecla 'W'
        elem = $('#warnings-tab-icon');
        tab_name = 'warnings';
      }
      else if (keyCode == 83) { // tecla 'S'
        elem = $('#search-tab-icon');
        tab_name = 'search';
      }

      parent = elem.parent();
      if (parent.hasClass('active'))
        sidebar.close(tab_name);
      else
        sidebar.open(tab_name);
    }
  }
});


//// o parametro "coords" � da forma -> "POINT(33.333 11.111)"
//// retorna um vector com 2 posi�oes, uma para cada coordenada
function parsePointCoordinates(coords) {
  var split_res = coords.split("(");
  var new_split_res = split_res[1].split(" ");

  var res = [];
  res.push(new_split_res[0]); //latitude
  res.push(new_split_res[1].split(")")[0]); //longitude

  return res;
}


function parseCoordinates(coords) {
  var i;
  var str_aux = "";
  var result = [];
  var temp_latlon;

  if (coords.indexOf("POINT") > -1) { // coordenadas de um ponto ou circulo
    str_aux = coords.split("(");
    str_aux = str_aux[1].split(")");
    str_aux = str_aux[0].split(" ");

    temp_latlon = L.latLng(str_aux[1], str_aux[0]);
    result.push(temp_latlon);
  }
  else if (coords.indexOf("POLYGON") > -1) { // coordenadas de um poligono
    str_aux = coords.split("((");
    str_aux = str_aux[1].split("))");
    str_aux = str_aux[0].split(", ");

    var t_coord;
    for (i = 0; i < str_aux.length; i++) {
      t_coord = str_aux[i].split(" ");
      temp_latlon = L.latLng(t_coord[1], t_coord[0]);
      result.push(temp_latlon);
    }
  }
  else if (coords.indexOf("LINESTRING") > -1) { // coordenadas de uma linha poligonal
    str_aux = coords.split("(");
    str_aux = str_aux[1].split(")");
    str_aux = str_aux[0].split(", ");

    var t_coord;
    for (i = 0; i < str_aux.length; i++) {
      t_coord = str_aux[i].split(" ");
      temp_latlon = L.latLng(t_coord[1], t_coord[0]);
      result.push(temp_latlon);
    }
  }

  return result;
}

// envia a entidade criada para a Base de Dados
function insertGeoEntity() {
  console.log("inserir nova entidaade");

  var name = $('#e_name').val();
  var description = $('#e_description').val();

  var sel_team_ids = [];
  $('#select_team_ids :selected').each(function () {
    sel_team_ids.push(parseInt($(this).val()));
  });

  console.log("***** PROPRIEDADES DA ENTIDADE *****");
  console.log("nome: " + name);
  console.log("tipo: " + e_type);
  console.log("raio: " + e_radius);
  console.log("descriçao: " + description);
  console.log("coordenadas: " + e_coords);
  console.log("id da equipa a associar: " + sel_team_ids);
  console.log("************************************");

  $.ajax({
    type: "POST",
    url: "/geo_entities",
    dataType: "json",
    data: {
      geo_entity: {
        name: name,
        entity_type: e_type,
        radius: e_radius,
        description: description,
        latlon: e_coords,
        team_ids: sel_team_ids
      }
    },
    // adicionamos o id à lista de ids e criamos uma popup para essa entidade
    success: function (data) {
      console.log("MARCADOR ADICIONADO COM SUCESSO");
      console.log(data);

      if (data.geometry.type === "Point") {
        var latlon = L.latLng(data.geometry.coordinates[1], data.geometry.coordinates[0]);
        geoPointToLayer(data, latlon);
      }

      onEachGeoEntity(data, e_layer);

      noty({
        text: 'Entidade geográfica introduzida com sucesso!', timeout: 3500,
        type: 'success', layout: 'bottomCenter'
      });

      drawnItems.addLayer(e_layer);
      map.addLayer(drawnItems);

      e_layer = null;

      // remove os valores do nome e descriçao que estavam no modal
      $('#e_name').val("");
      $('#e_description').val("");
      $("#select_team_ids option").prop("selected", false);
    },
    error: function (err) {
      noty({
        text: 'Erro a introduzir a entidades geográfica!', timeout: 3500,
        type: 'error', layout: 'bottomCenter'
      });

      console.log("erro a adicionar o marcador");
      console.log(err);
      e_layer = null;
    }
  });
}

$('.stay-where-you-are').click(function (e) {
  // do something fancy
  return false; // prevent default click action from happening!
  //e.preventDefault(); // same thing as above
});

// recebe o json do servidor, processa-o e adiciona as entidades ao mapa
function addGeoEntityToMap(json) {
  console.log("UPDATES server sent event!!!!!!");

  var new_layer;
  var json_arr = JSON.parse(json);
  var latlon_arr = [];
  var ent_type;

  console.log(json_arr);

  // apenas uma entidade retornada pelo servidor
  if (json_arr.type == "Feature") {

    // esta feature ainda nao existe no array!!
    if (geoEntityIsInMap(json_arr.properties.f_id) == -1) {
      console.log("FEATURE FEATURE - ainda nao existe no array");

      new_layer = L.geoJson(json_arr, {
        pointToLayer: geoPointToLayer,
        onEachFeature: onEachGeoEntity
      }).addTo(map);

      cluster.addLayer(new_layer);
      map.addLayer(cluster);

      noty({
        text: 'Uma entidade geográfica foi atualizada!', timeout: 3500,
        type: 'success', layout: 'bottomCenter'
      });
    }
  }
  // mais do que uma entidade retornada pelo servidor
  else if (json_arr.type == "FeatureCollection") {
    console.log("MAIS QUE UMA ENTIDADE, VAMOS ENTRAR NO FOR EACH!!!");

    // array GEOJSON que no final conterá todas as entidades que ainda nao estejam no mapa
    var final_json_arr = {
      "type": "FeatureCollection",
      "features": []
    };

    var new_features_count = 0;
    $.each(json_arr.features, function (index, elem) {
      var f_id = elem.properties.f_id;
      console.log(all_geo_entities);
      console.log(f_id);

      var alreadyInMap = geoEntityIsInMap(f_id);

      console.log("f_id está contida no array?? " + alreadyInMap);

      // esta feature ainda nao existe no array!!
      if (alreadyInMap == -1) {
        final_json_arr.features.push(elem);
        new_features_count++;
      }
    });

    new_layer = L.geoJson(final_json_arr, {
      pointToLayer: geoPointToLayer,
      onEachFeature: onEachGeoEntity
    }).addTo(map);

    cluster.addLayer(new_layer);
    map.addLayer(cluster);

    if (new_features_count == 1)
      noty({
        text: 'Uma nova entidade geográfica foi adicionada ao mapa!', timeout: 3500,
        type: 'success', layout: 'bottomCenter'
      });
    else if (new_features_count > 1)
      noty({
        text: 'Várias novas entidades geográficas foram adicionadas ao mapa!', timeout: 3500,
        type: 'success', layout: 'bottomCenter'
      });
  }
}

function addTeamToMap(json) {
  console.log("RECEBEMOS NOVA EQUIPA!!!!");

  var new_layer;
  var json_arr = JSON.parse(json);
  console.log(json_arr);

  new_layer = L.geoJson(json_arr, {
    pointToLayer: teamPointToLayer,
    onEachFeature: onEachTeam
  });

  if (json_arr.type === "Feature")
    noty({
      text: 'Uma equipa foi atualizada!', timeout: 3500,
      type: 'success', layout: 'bottomCenter'
    });
  else
    noty({
      text: 'Várias equipas foram atualizadas!', timeout: 3500,
      type: 'success', layout: 'bottomCenter'
    });

  cluster.addLayer(new_layer);
  map.addLayer(cluster);
}


// ****************** SSE STUFF :) ************************
function eventSourceSetup() {
  console.log("START DA CENA DO EVENT_SOURCE");

  // SSE stuff - atualização de informação
  if (!!window.EventSource)
    source = new EventSource("/entity_updates");
  else {
    // Result to xhr polling :(
  }

  // listener para a receção de updates de entidades geograficas
  source.addEventListener('entity_updates', function (e) {
    is_sse_update = true;
    addGeoEntityToMap(e.data);
    is_sse_update = false;
  }, false);

  // listener para a receçao de updates das equipas
  source.addEventListener('team_updates', function (e) {
    is_sse_update = true;
    addTeamToMap(e.data);
    is_sse_update = false;
    cleanRemovedTeams();
  }, false);
}

// remove do array de equipas todas as equipas que tenham sido eliminadas através dos updates via SSE
function cleanRemovedTeams() {
  console.log("equipas para remover:");
  console.log(teams_to_remove);

  if (teams_to_remove.length > 0) {
    var temp_arr = [];
    $.each(teams_to_remove, function (index, elem) {
      cluster.removeLayer(elem.marker);
      map.removeLayer(elem.marker);
      temp_arr.push(elem.id);
    });

    all_teams = $.grep(all_teams, function (elem, index) {
      return $.inArray(elem.id, temp_arr) == -1;
    });

    teams_to_remove = [];
    console.log("acabei de limpar as equipas que ja tinham sido removidas!");
  }
}


// ****************** TESTE GEOLOCALIZAÇÃO ************************
//function getUserPositionGPS() {
//  map.findAccuratePosition({
//    maxWait: 12500, // defaults to 10000
//    desiredAccuracy: 20 // defaults to 20
//  });
//
//  setTimeout(getUserPositionGPS, 15000);
//}
//
//function onAccuratePositionProgress(e) {
//  console.log("A OBTER A POSIÇÃO!!");
//  console.log(e);
//}
//
//function onAccuratePositionFound(e) {
//  console.log("POSIÇÃO OBTIDA!!");
//  console.log(e);
////  map.setView(e.latlng, 16);
//  L.marker(e.latlng).addTo(map);
//
//  var d = new Date();
//  var time = d.toLocaleTimeString();
//
//  var li = $('<li/>').addClass('collection-item');
//  var span1 = $('<span/>').text("Coordenadas: [" + e.latlng.lat + "; " + e.latlng.lng + "]");
//  var span2 = $('<span/>').text("Precisão da medição: " + e.accuracy + " metros");
//  var span3 = $('<span/>').text("Data do sistema: " + time);
//
//  li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
//  $('#current_position_list').prepend(li);
//}
//
//function onAccuratePositionError(e) {
//  console.log("ERRO A OBTER A POSIÇÃO!!");
//  console.log(e)
//}


//function teste() {
//  navigator.wakeLock.request("display").then(
//      function successFunction() {
//        // success
//        console.log("foda-se sucesso1");
//      },
//      function errorFunction() {
//        // error
//        console.log("foda-se erro1");
//      }
//  );
////here system indicates CPU, GPU, radio, wifi etc.
//  navigator.wakeLock.request("system").then(
//      function successFunction() {
//        // success
//        console.log("foda-se sucesso1");
//      },
//      function errorFunction() {
//        // error
//        console.log("foda-se erro1");
//      }
//  );
//}


//function cenaGPS() {
//  var options = {
//    enableHighAccuracy: true,
//    timeout: 85000,
//    maximumAge: 10000
//  };
//
//  function onsuccess(pos) {
//    console.log(pos);
//    var c_latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
////    var c_text = "POINT(" + c_latlng.lng + " " + c_latlng.lat + ")";
//
//    console.log("POSIÇÃO OBTIDA!!");
//    console.log(c_latlng);
//
//    var positionDate = new Date(pos.timestamp);
//    var currentDate = new Date();
//    console.log(positionDate.toLocaleString(), currentDate.toLocaleString());
//
//    var distance = -1;
//    if (typeof current_user_location !== 'undefined')
//      distance = current_user_location.distanceTo(c_latlng);
//
//    console.log("DISTANCIA PARA MEDIÇÃO ANTERIOR: " + distance);
//
//    // envia a nova posição para o servidor caso seja a primeira vez ou
//    // a distancia para a posição anterior seja superior a 10 metros
//    if (distance == -1 || distance > 10) {
//      console.log("POSIÇÃO ATUAL A MAIS DE 10M DA ANTERIOR!");
//
//      $.ajax({
//        type: "POST",
//        url: "/update_location",
//        data: {
//          latitude: pos.coords.latitude,
//          longitude: pos.coords.longitude,
//          user_id: gon.user_id
//        },
//        success: function (result) {
//          console.log(result);
//
//          var new_marker = L.marker(c_latlng, {icon: user_pos_icon});
//          cluster.addLayer(new_marker);
//          map.addLayer(cluster);
//
//          var d = new Date();
//          var time = d.toLocaleTimeString();
//
//          var li = $('<li/>').addClass('collection-item');
//          var span1 = $('<span/>').text("Coordenadas: [" + pos.coords.latitude + "; " + pos.coords.longitude + "]");
//          var span2 = $('<span/>').text("Precisão da medição: " + pos.coords.accuracy + " metros");
//          var span3 = $('<span/>').text("Data do sistema: " + time);
//
//          li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
//          $('#current_position_list').prepend(li);
//        },
//        error: function (err) {
//          console.log(err);
//        }
//      });
////      map.setView(c_latlng, 16);
//    }
//    current_user_location = c_latlng;
//  }
//
//  // PERMISSION_DENIED = 1;
//  // POSITION_UNAVAILABLE = 2;
//  // TIMEOUT = 3;
//  function onerror(err) {
//    console.warn('ERROR(' + err.code + '): ' + err.message);
//  }
//
//  navigator.geolocation.getCurrentPosition(onsuccess, onerror, options);
//  setTimeout(cenaGPS, 10000);
//}


/*
 * Verifica se a equipa ja existe ou nao no mapa
 * Retorna -1 caso a equipa nao esteja no mapa
 * Retorna o indice caso a equipa ja exista no mapa
 */
function teamIsInMap(param_id) {
  var i;
  for (i = 0; i < all_teams.length; i++) {
    if (all_teams[i].id === param_id) // a equipa existe
      return i;
  }
  return -1;
}

/*
 * Verifica se a entidade geografica ja existe ou nao no mapa
 * Retorna -1 caso nao esteja no mapa
 * Retorna o indice caso ja exista no mapa
 */
function geoEntityIsInMap(param_id) {
  var i;
  for (i = 0; i < all_geo_entities.length; i++) {
    if (all_geo_entities[i].id === param_id) // a entidade geografica existe
      return i;
  }
  return -1;
}

/*
 * apresenta as coordenadas da entidade selecionada num modal no fundo da pagina
 * recebe o id que a entidade tem na base de dados, que dps é transformado para a entrada no vector de entidades no mapa
 */
function showEntityCoordinates(entity_index) {
  var index_in_array = geoEntityIsInMap(entity_index);

  if (index_in_array > -1) {
    var geo_entity = all_geo_entities[index_in_array];
    var text_coords = "";

    $.each(geo_entity.latlon, function (index, elem) {
      text_coords += "(" + elem.lat + ", " + elem.lng + ")";
      if (index < geo_entity.latlon.length - 1)
        text_coords += ";    ";
    });

    var num_points = "";
    if (geo_entity.latlon.length == 1)
      num_points = "1 ponto";
    else
      num_points = geo_entity.latlon.length + " pontos";

    $("#modal_entity_type").text(geo_entity.type);
    $("#modal_num_points").text(num_points);
    $("#modal_coords").text(text_coords);
    $('#modal_entity_coordinates').openModal();
  }
  else
    noty({
      text: 'Erro a apresentar as coordenadas da entidade.', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
}

// função chamada quando o utilizador quer remover uma geo-entidade
function removeGeoEntity(entity_index) {
  if (confirm("De certeza que pretende remover esta geo-entidade?\nEsta ação é irreversível!")) {
    var index_in_array = geoEntityIsInMap(entity_index);

    if (index_in_array > -1) {
      $.ajax({
        type: "DELETE",
        url: "/geo_entities/" + entity_index,
        dataType: "json",
        success: function (res) {
          // a entidade foi removida com sucesso da base de dados: vamos remove-la do mapa e do vector de entidades
          var layer_to_remove = all_geo_entities[index_in_array].layer;
          cluster.removeLayer(layer_to_remove);
          map.removeLayer(layer_to_remove);

          // removemos a entidade do array de entidades presentes no mapa
          all_geo_entities = $.grep(all_geo_entities, function (elem, index) {
            return elem.id != entity_index;
          });

          noty({
            text: 'Geo-entidade removida com sucesso.', timeout: 3500,
            type: 'success', layout: 'bottomCenter'
          });
        },
        error: function (res) {
          noty({
            text: 'Ocorreu um erro a remover a entidade.\nTente novamente mais tarde.', timeout: 4000,
            type: 'alert', layout: 'bottomCenter'
          });
        }
      });
    }
    else {
      noty({
        text: 'Ocorreu um erro a remover a entidade.\nExperimente recarregar a página.', timeout: 4000,
        type: 'alert', layout: 'bottomCenter'
      });
    }
  }
}


// função executada pelo onEachFeature do metodo geoJSON das equipas
function onEachTeam(feature, layer) {
  // se a data de atualização for null é porque a equipa é para remover!!!!
  // caso contrario, associamos a popup como normal!
  if (feature.properties.updated_at !== null) {
    var popup = L.popup({maxWidth: 250});
    var content = '<span>Equipa número <b>' + feature.properties.f_id + '</b><br>' +
        '<b>Nome: </b>' + feature.properties.name + '<br>' +
        '<b>Líder: </b><a data-method="get" href="/users/' + feature.properties.leader_id + '">' +
        feature.properties.leader_name + '</a><br><b>Responsável pela posição: </b>' +
        '<a data-method="get" href="/users/' + feature.properties.location_user_id + '">' +
        feature.properties.location_user_name + '</a></span>';

    // so coloca as coordenadas de destaque na popup caso a equipa em questao esteja destacada
    if (feature.properties.highlight_coords !== null) {
      var parsed_highlight_coords = parsePointCoordinates(feature.properties.highlight_coords);
      content += '<p>Esta equipa está destacada para as coordenadas: <br>' +
          '<b>Latitude: </b>' + parsed_highlight_coords[1] + ';<br>' +
          '<b>Longitude: </b>' + parsed_highlight_coords[0] + '</p>'
    }
    else
      content += '<p>Esta equipa não está destacada para nenhum ponto. </p>';

    content += '<div class="center-align"><a data-method="get" href="/teams/' + feature.properties.f_id + '" ' +
        'class="waves-effect waves-light btn white-text" target="_blank" style="width: 100%;">Ir para equipa</a></div>';

    popup.setContent(content);
    layer.bindPopup(popup);
  }
}

/**
 * função executada pelo pointToLayer do metodo geoJSON das equipas
 * verifica se esta entidade ja existe no sistema
 * se sim, removemos para voltar a introduzir
 * caso a data de atualização for null, removemos a entidade
 *
 * @param feature
 * @param latlng
 */
function teamPointToLayer(feature, latlng) {
  console.log(feature);
  var index = teamIsInMap(feature.properties.f_id);
  var new_marker = L.marker(latlng, {icon: team_icon});
  var old_marker, team_to_push;
  var curr_action;

  if (index == -1) {//equipa nao existe no mapa
    team_to_push = {id: feature.properties.f_id, marker: new_marker};
    all_teams.push(team_to_push);
    curr_action = actions.create;

    console.log("NOVA EQUIPA RECEBIDA!!!");
  }
  else {
    old_marker = all_teams[index].marker;
    all_teams[index].marker = new_marker;
    team_to_push = all_teams[index];

    cluster.removeLayer(old_marker);
    map.removeLayer(old_marker);

    curr_action = actions.update;
  }

  if (feature.properties.updated_at === null) {
    teams_to_remove.push(team_to_push);
    curr_action = actions.remove;
  }

  // updates periodicos enviados pelo servidor
  // apenas precisamos de guardar historico para updates do servidor ou ações do utilizador criadas durante a sessao
  if (is_sse_update) {
    createNewHistoryEntry(object_type.team, feature.properties.f_id, new Date(), curr_action);
  }


  return new_marker;
}

// função executada pelo pointToLayer do metodo geoJSON das entidades geograficas
function geoPointToLayer(feature, latlng) {
  if (feature.properties.radius > 0)
    return L.circle(latlng, feature.properties.radius);
  else
    return L.marker(latlng);
}

// função executada pelo onEachFeature do metodo geoJSON das entidades geograficas
function onEachGeoEntity(feature, layer) {
  var ent_type, temp_latlon, radius = 0;
  var popup = L.popup({maxWidth: 250});

  // no caso de ser circulo, introduzimos o raio na popup
  if (feature.properties.radius > 0) {
    ent_type = entity_types.circle;
    radius = feature.properties.radius;
  }
  else {
    if (feature.geometry.type === "LineString")
      ent_type = entity_types.linestring;
    else if (feature.geometry.type === "Polygon")
      ent_type = entity_types.polygon;
    else if (feature.geometry.type === "Point")
      ent_type = entity_types.point;
  }

  var popupContent = '<span>Entidade geográfica nº <b>' + feature.properties.f_id +
      '</b>, adicionada pelo utilizador <a data-method="get" href="/users/' + feature.properties.user_id + '">' +
      feature.properties.username + '</a>.</span><p><b>Tipo: </b>' + ent_type + '<br>' +
      (radius > 0 ? '<b>Raio: </b>' + radius + ' metros<br>' : '') + '<b>Nome: </b>' + feature.properties.name + '<br>' +
      '<b>Descrição: </b>' + feature.properties.description + '</p><div style="display: inline-block">' +
      '<a href="javascript:showEntityCoordinates(' + feature.properties.f_id + ');" ' +
      'class="geo-popup-btn waves-effect waves-light btn white-text">Ver coordenadas</a></div>' +
      '<div style="display: inline-block" class="right"><a href="javascript:removeGeoEntity(' +
      feature.properties.f_id + ');" class="geo-popup-btn red waves-effect waves-light btn white-text">' +
      '<i class="material-icons">delete</i></a></div>';

  popup.setContent(popupContent);
  layer.bindPopup(popup);

  if (layer.hasOwnProperty('_latlng')) // só tem um par de coordenadas
    temp_latlon = [layer.getLatLng()];
  else if (layer.hasOwnProperty('_latlngs')) // tem mais do que um par de coordenadas
    temp_latlon = layer.getLatLngs();

  all_geo_entities.push({id: feature.properties.f_id, latlon: temp_latlon, type: ent_type, layer: layer});
}


// caso o URL contenha o campo 'entity_id', vamos verificar se a entidade existe no mapa
// se sim, centramos o mapa nessa entidade.
function centerMapOnGeoEntity(entity_id) {
  var indexOnArray = geoEntityIsInMap(entity_id);

  if (indexOnArray > -1) { // a entidade existe, centramos
    var entity = all_geo_entities[indexOnArray];
    map.fitBounds(entity.latlon, {maxZoom: parseInt(curr_user_saved_prefs.max_zoom)});
    entity.layer.openPopup();

    noty({
      text: 'Mapa centrado na geo-entidade nº' + entity_id + '.', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  }
  else
    noty({
      text: 'A geo-entidade nº' + entity_id + ' não existe no sistema.', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
}

// função que verifica se o parametro passado em argumento esta presente no URL
// se sim, devolve o valor correspondente a esse parametro
function getURLParameter(param) {
  var search_params = window.location.search.substring(1);
  var search_vars = search_params.split('&');

  for (var i = 0; i < search_vars.length; i++) {
    var param_name = search_vars[i].split('=');

    if (param_name[0] == param)
      return param_name[1];
  }
}

/**
 * Le as preferencias do utilizador a partir do localStorage
 */
function checkUserPreferences() {
  var local_storage_user_prefs = JSON.parse(localStorage.getItem('user' + gon.user_id));
  console.log("preferencias do utilizador");
  console.log(local_storage_user_prefs);

  var show_navbar_checkbox = $('#homepage-toggle-navbar');

  // o utilizador ja iniciou sessão, vamos obter as suas preferencias
  if (local_storage_user_prefs !== null) {
    // le as entradas a partir do localStorage e coloca-as na timeline
    populateEventHistory(local_storage_user_prefs.events_history);

    // altera o nivel de zoom máximo para aquele que o utilizador definiu previamente
    $("#range_max_zoom").val(local_storage_user_prefs.max_zoom);
    curr_user_saved_prefs.max_zoom = local_storage_user_prefs.max_zoom;

    // apresenta ou esconde a navbar consoante as preferencias do utilizador
    if (!local_storage_user_prefs.show_navbar) {
      toggleNavBar(false);
      show_navbar_checkbox.prop('checked', false);
    }
    else {
      toggleNavBar(true);
      show_navbar_checkbox.prop('checked', true);
    }
  }
  else {
    toggleNavBar(true);
    console.log(curr_user_saved_prefs);
  }
}

/**
 * mostra ou esconde a barra de navegação
 * grava no localStorage o estado atual da navbar
 * @param to_show
 */
function toggleNavBar(to_show) {
  var new_sidebar_height, new_top;
  var curr_window_height = window.innerHeight,
      curr_window_width = window.innerWidth,
      navbar_height = $('#frontpage-navbar').height(),
      new_map_height = window.innerHeight - navbar_height,
      sidebar_padding = 10;

  if (to_show) {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_top = navbar_height;
      new_sidebar_height = curr_window_height - navbar_height;
    }
    else {
      new_top = navbar_height + sidebar_padding;
      new_sidebar_height = curr_window_height - navbar_height - 2 * sidebar_padding;
    }

    $('#frontpage-navbar').slideDown({queue: false});
    $('#map').animate({'height': new_map_height, duration: 'slow', queue: false});
    $('#sidebar').animate({'top': new_top + 'px', 'height': new_sidebar_height + 'px', duration: 'slow', queue: false});
    curr_user_saved_prefs.show_navbar = true;
  }
  else {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_top = 0;
      new_sidebar_height = curr_window_height;
    }
    else {
      new_top = sidebar_padding;
      new_sidebar_height = curr_window_height - 2 * sidebar_padding;
    }

    $('#frontpage-navbar').slideUp({queue: false});
    $('#sidebar').animate({'top': new_top + 'px', 'height': new_sidebar_height + 'px', duration: 'slow', queue: false});
    $('#map').animate({'height': '100%', queue: false});
    curr_user_saved_prefs.show_navbar = false;
  }
  localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
}

// cria novos objectos HistoryEntry a partir do que foi lido do localStorage
function populateEventHistory(loaded_events) {
  console.log("vamos popular o historico do user");
  var arr = [], i, entry;

  for (i = 0; i < loaded_events.length; i++) {
    entry = new HistoryEntry(loaded_events[i].obj_type, loaded_events[i].obj_id, loaded_events[i].timestamp,
        loaded_events[i].action, loaded_events[i].watched);
    prependHistoryDivEntry(entry);
    arr.push(entry);
  }

  curr_user_saved_prefs.events_history = arr;
}


// ajusta o tamanho do mapa, navbar e sidebar quando a janela é redimensionada
function onWindowResize(event) {
  var new_sidebar_top, new_sidebar_height;
  var curr_window_height = window.innerHeight,
      curr_window_width = window.innerWidth,
      navbar_height = $('#frontpage-navbar').height(),
      new_map_height = curr_window_height - navbar_height;

  if (curr_user_saved_prefs.show_navbar) {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_sidebar_top = 56;
      new_sidebar_height = curr_window_height - navbar_height;
    }
    else {
      new_sidebar_top = 74;
      new_sidebar_height = curr_window_height - navbar_height - 20;
      console.log("aqui aqui");
    }

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#map').css({height: new_map_height});

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#sidebar').css({height: new_sidebar_height, top: new_sidebar_top + 'px'});
  }
  else {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_sidebar_top = 0;
      new_sidebar_height = curr_window_height;
    }
    else {
      new_sidebar_top = 10;
      new_sidebar_height = curr_window_height - 20;
      console.log("aqui aqui");
    }

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#map').css({height: '100%'});

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#sidebar').css({height: new_sidebar_height, top: new_sidebar_top + 'px'});
  }
}

// recebe os parametros do novo evento, adiciona-o ao localStorage do utilizador atual
function createNewHistoryEntry(o_type, o_id, time, event, watch) {
  var h_entry = new HistoryEntry(o_type, o_id, time, event, watch);

  if (!containsHistoryEntry(h_entry)) {
    curr_user_saved_prefs.events_history.push(h_entry);
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));

    prependHistoryDivEntry(h_entry);
    console.log("esta entrada nao existe, espetamos a gaja no historico kkkkkk!");
  }
  else
    console.log("esta entrada ja existe, nao fazemos nada!");
}


function prependHistoryDivEntry(entry) {
  console.log("PREPEND DA CENA DO HISTORICO!!!");
  var icon, new_element, info_text, time_span_to_string;
  var icon_to_center = "";
  var when_was_updated = "";

  console.log(entry.watched);

  if (entry.action === actions.create || entry.action === actions.update) {
    //icon_to_center = '<i class="material-icons right">my_location</i>';
    icon_to_center = '<a class="waves-effect waves-light btn-flat right" ' +
        'onclick="javascript:centerMapOnGeoEntity(' + entry.obj_id + ')"' +
        'style="padding: 8px; line-height: normal; top: -10px; height: 38px;">' +
        '<i style="line-height: 23px !important;" class="material-icons md-24">my_location</i></a>';

    if (entry.action === actions.create) {
      icon = 'add';
      info_text = 'adicionada ao mapa.';
    }
    else if (entry.action === actions.update) {
      icon = 'edit';
      info_text = 'atualizada.';
    }
  }
  else if (entry.action === actions.remove) {
    icon = 'delete';
    info_text = 'removida do sistema.';
  }

  if(is_sse_update)
    when_was_updated = "Agora mesmo";
  else {
    // a diferença entre duas datas é retornada em milisegundos
    // divide-se por 1000 para ficar com o valor em segundos
    var date_param = Math.round(Math.abs(new Date(entry.timestamp) - new Date()) / 1000);
    time_span_to_string = timeDiffToString(date_param);
    when_was_updated = "Há " + time_span_to_string;
  }

  new_element = '<div class="timeline-item">' +
      '<div class="timeline-icon valign-wrapper ' + (entry.watched ? "" : "new-entry-icon") + '">' +
      '<i class="timeline-custom-icon material-icons md-24">' + icon + '</i></div>' +
      '<div class="timeline-content z-depth-1 ' + (entry.watched ? "" : "new-entry-content") + '">' +
      '<h6 class="' + (entry.watched ? "" : "new-entry-header") + '" style="font-size: large;"><span>' +
      entry.obj_type + ' ' + entry.action + '</span>' + icon_to_center + '</h6><div style="margin-top: 5px;"><div>' +
      '<span class="timeline-timestamp" style="font-style: italic; font-size: 12px;">' + when_was_updated +
      '</span></div><div><p style="margin: 0;">A ' + entry.obj_type.toLowerCase() + ' número ' +
      '<a data-method="get" target="_blank" href="/teams/' + entry.obj_id + '">' + entry.obj_id +
      '</a> foi ' + info_text + '</p></div></div></div></div>';

  $('#timeline').prepend(new_element);

  if (!entry.watched) {
    var badge_icon = $('#history-tab-icon');
    var nr_of_pending_notifs = $(badge_icon).attr('data-badge'); // undefined se não houver nenhuma notificação

    nr_of_pending_notifs === undefined ? $(badge_icon).attr('data-badge', '1')
        : $(badge_icon).attr('data-badge', parseInt(nr_of_pending_notifs) + 1);
  }
}

/**
 * metodo que verifica se a entrada passada como parametro ja existe no array de entradas do utilizador
 * devolve 'true' caso a ação, o id e o tipo sejam iguais e a diferença entre as timestamps seja menor que 22 segundos
 * (o tempo que vai entre 2 updates automaticos do servidor!)
 * devolve 'false' caso alguma destas condições falhe.
 *
 * Exemplo1:
 * obj1 = {obj_type: "Equipa", obj_id: 17, timestamp: "2015-12-18T15:12:29.654Z", action: "atualizada"}
 * obj2 = {obj_type: "Equipa", obj_id: 17, timestamp: "2015-12-18T15:12:49.654Z", action: "atualizada"}
 * devolve 'true' pois todas as condições são verdadeiras - caso a timestamp tivesse mais 3 segundos
 * ja devolvia 'false' - podia tratar-se de outro update que não o mesmo
 */
function containsHistoryEntry(obj) {
  var i;
  for (i = 0; i < curr_user_saved_prefs.events_history.length; i++) {
    if (curr_user_saved_prefs.events_history[i].equals(obj))
      return true;
  }
  return false;
}

/**
 * recebe como parametro os segundos que queremos tratar
 */
function timeDiffToString(seconds) {
  var days, hours, minutes, string_to_ret = "";

  days = Math.floor(seconds / 86400); // numero de dias
  seconds -= days * 86400;
  hours = Math.floor(seconds / 3600); // numero de horas inteiras
  seconds -= hours * 3600;
  minutes = Math.floor(seconds / 60); // numero de minutos que sobram
  seconds -= minutes * 60;

  if (days > 0)
    string_to_ret += days + (days == 1 ? " dia, " : " dias, ");
  if (hours > 0)
    string_to_ret += hours + (hours == 1 ? " hora, " : " horas, ");
  if (minutes > 0)
    string_to_ret += minutes + (minutes == 1 ? " minuto e " : " minutos e ");
  if (seconds > 0)
    string_to_ret += seconds + (seconds == 1 ? " segundo" : " segundos");

  return string_to_ret;
}

/**
 * Atualiza as timestamps das entradas do historico a cada x segundos
 * Por enquanto esse valor fica nos 30 segundos - 30k milissegundos
 */
function updateTimestamps() {
  console.log("ATUALIZAR AS TIMESTAMPS!!!!!");
  console.log(new Date());

  var dom_elem, t_stamp_span, date_param;
  var items = $('.timeline-item');
  var length = items.length - 1; //para evitar aceder a posições fora de alcance - famoso indexOutOfBounds kkkk

  $.each(curr_user_saved_prefs.events_history, function (index, elem) {
    dom_elem = $(items).get(length - index);
    t_stamp_span = $(dom_elem).find('.timeline-timestamp');

    date_param = Math.round(Math.abs(new Date(elem.timestamp) - new Date()) / 1000);
    $(t_stamp_span).text("Há " + timeDiffToString(date_param));
  });

  setTimeout(updateTimestamps, 30000);
}