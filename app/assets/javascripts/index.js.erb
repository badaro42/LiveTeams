// **************************************
// constantes
var SMARTHPHONE_MAX_WIDTH = 600;
var geo_entity_types = {
  circle: "Círculo",
  rectangle: "Rectângulo",
  point: "Ponto",
  polygon: "Polígono",
  linestring: "Linha Poligonal"
};
var object_type = {
  team: "Equipa",
  geo_entity: "Geo-entidade"
};
var actions = {
  update: "atualizada",
  remove: "removida",
  create: "criada"
};


// **************************************
// objectos

// este objeto representa uma geo-entidade
function GeoEntity(id, name, description, user_name, user_id, radius, updated_at, type, layer) {
  this.f_id = id; // o id da geo-entidade na base de dados
  this.f_name = name; // o nome da geo-entidade
  this.description = description; // a descrição da geo-entidade
  this.user_name = user_name; // o nome do utilizador que criou a geo-entidade
  this.user_id = user_id; // o id do utilizador que criou a geo-entidade
  this.radius = radius; // o raio da geo-entidade (> 1 se círculo, 0 caso contrario)
  this.updated_at = updated_at; // a data de atualização da geo-entidade
  this.ent_type = type; // o tipo da geo-entidade. ver 'geo_entity_types'
  this.layer = layer; // o objeto que representa esta geo-entidade no mapa
}

// este objeto representa uma equipa
function Team(id, name, loc_user_id, loc_user_name, updated_at, leader_name, leader_id, highlight_coords, marker) {
  this.t_id = id; // o id da equipa na base de dados
  this.t_name = name; // o nome da equipa
  this.location_user_id = loc_user_id; // o id do utilizador responsavel pela localização da equipa
  this.location_user_name = loc_user_name; // o nome do utilizador responsavel pela localização da equipa
  this.updated_at = updated_at; // a data de atualização da equipa
  this.leader_name = leader_name; // o nome do lider da equipa
  this.leader_id = leader_id; // o id do lider da equipa
  this.highlight_coords = highlight_coords; // as coordenadas de destaque da equipa
  this.marker = marker; // o objeto que representa o marcador da equipa no mapa
}

// este objeto representa uma entrada do histórico apresentado na barra lateral
function HistoryEntry(o_type, o_id, title, time, event, watch, user_name, user_id) {
  this.obj_type = o_type; // o tipo do objecto
  this.obj_id = o_id; // o id do objecto
  this.title = title; // o titulo da entrada: nome da equipa e da geo-entidade
  this.timestamp = time; // a data em que ocorreu a ação
  this.action = event; // o evento que ocorreu
  this.watched = watch; // indica se a entrada atual ja foi vista pelo utilizador
  this.username = user_name; // o nome do utilizador que realizou a ação
  this.user_id = user_id; // o id do utilizador que realizou a ação
}
// override do metodo 'equals' para comparar os campos que queremos nas entradas do historico
// ver comentario do metodo 'containsHistoryEntry' para uma melhor explicação
HistoryEntry.prototype.equals = function (o) {
  var time_diff = Math.abs(o.timestamp - this.timestamp);
  return this.obj_type === o.obj_type && this.action === o.action && this.obj_id === o.obj_id &&
      (time_diff < 20000);
};


// **************************************
// variaveis da mais variada especie :)
var map, osmUrl, osmAttrib, osm, sidebar, cluster;
var user_centered_circle;
var drawnItems;
var e_type, e_radius, e_coords, coords_to_display, e_length, e_area, e_layer, e_num_points;

var add_to_event_history = false;

// cada entrada é da forma {id: feature_id, type: tipo (em portugues),
// latlon: array com objetos L.latLng), layer: o objeto que esta no mapa}
var all_geo_entities;
var all_teams; // cada entrada é da forma {id: feature_id, marker: L.marker(L.latLng(lat, lng))}
var teams_to_remove = [];
var geo_ents_to_remove = [];
var source;

var new_teams_count = 0;
var updated_teams_count = 0;
var removed_teams_count = 0;

var previous_user_location; // {timestamp: Date(), position: L.latLng(lat, lng)}
var no_sleep_enabled = false;
var is_modal_open = false;


// variaveis relacionadas a informação guardada no browser - localStorage
var curr_user_saved_prefs = { // local storage - objeto com as preferencias do utilizador!
  show_navbar: null, // o estado de visibilidade da navbar na pagina inicial
  events_history: [], // array com todas as entradas do historico
  max_zoom: 16, // valor default: se houver valor no localStorage, substitui este
  history_entries_limit: 25 // controla o numero maximo de entradas no historico
};
var last_window_height;


// var incrementada quando um dos conjuntos de dados é carregado - equipas e entidades
var geo_data_loaded = 0;

var team_icon = L.icon({
  iconUrl: '/assets/team_icon.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});

var user_pos_icon = L.icon({
  iconUrl: '/assets/user-64.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});

/**
 * Função executada quando o DOM está pronto a ser manipulado pelo javascript
 * Dentro desta função estão todas as inicializações e listeners
 */
$(document).ready(function () {
  // inicialização da dropdown da barra de navegação
  $('.dropdown-button').dropdown({
        inDuration: 300,
        outDuration: 225,
        constrain_width: true, // Does not change width of dropdown to that of the activator
        hover: true, // Activate on hover
        gutter: 0, // Spacing from edge
        belowOrigin: true, // Displays dropdown below the button
        alignment: 'left' // Displays dropdown with edge aligned to the left of button
      }
  );

  // inicialização da barra de navegação lateral
  $(".button-collapse").sideNav();

  // remove as notificações da sidebar quando o utilizador fecha a sidebar apenas quando a tab aberta era
  // a do historico de eventos
  $('#history-tab-icon').on('click', function (e) {
    console.log(e.currentTarget);
    var parent = $(e.currentTarget).parent();

    // remove o indicador de notificações novas, coloca todas as entradas como vistas e grava-as no localStorage
    if (!parent.hasClass('active')) {
      $.each(curr_user_saved_prefs.events_history, function (index, elem) {
        elem.watched = true;
      });
      localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));

      if ($(e.currentTarget).attr('data-badge') !== undefined) {
        console.log("ha pelo menos uma entrada nova, vamos limpar as notificaçoes e remover as classes");
        setTimeout(function () {
          $(e.currentTarget).attr('data-badge', null);
          $('.timeline-item div').removeClass("new-entry-content new-entry-icon");
          $('.timeline-content h6').removeClass("new-entry-header");
        }, 10000);
      }
    }
  });

  // verifica as preferencias do utilizador no objeto localStorage
  last_window_height = window.innerHeight;
  checkUserPreferences();

  // chama a função para atualizar as timestamps da entradas
  // esta função é executada a cada 30 segundos
  setTimeout(updateTimestamps, 30000);

  // listener que é executado quando a janela é redimensionada
  window.onresize = onWindowResize;

  // listener para quando o utilizador carrega na checkbox para mostrar/esconder a navbar
  $('#homepage-toggle-navbar').on('change', function () {
    if ($(this).is(':checked'))
      toggleNavBar(true);
    else
      toggleNavBar(false);
  });

  // listener para os botoes da sidebar que faz scroll para o inicio da lista
  $(".scrollTop").on('click', function (e) {
    var elem = e.toElement;
    $(elem).closest(".list_wrapper").animate({
      scrollTop: 0
    });
  });

  // seleciona todas as equipas no modal para criar entidade
  $('#select_all_teams').on('click', function () {
    console.log("select_all_teams clique");
    $('#select_team_ids option').prop('selected', true);
  });

  // remove a selecção de todas as equipas no modal para criar entidade
  $('#select_no_teams').on('click', function () {
    console.log("select_no_teams clique");
    $('#select_team_ids option').prop('selected', false);
  });

  $('#button-da-merda').on('click', function () {
    console.log("CARREGUEI NO BOTAO!!! HEHE");
    $('#modal_entity_coordinates').openModal();
  });

  // apenas permite numeros no campo do numero de telefone
  $(".numeric").numeric();

  // listener para quando o valor do slider nas opções é alterado
  $('#range_max_zoom').on('change', function () {
    console.log("slider max zoom!!!");
    curr_user_saved_prefs.max_zoom = $(this).val();
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
  });

  // listener para quando o valor do slider nas opções é alterado
  $('#range_history_entry_max').on('change', function () {
    console.log("slider history entries max!!!");

    $('#entries_number').text($(this).val());
    curr_user_saved_prefs.history_entries_limit = $(this).val();
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
  });

  // apenas ativa a cena do wake lock caso seja um dispositivo movel
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.test(navigator.userAgent)) {
    // Take the user to a different screen here.
//    alert("Dispositivo Móvel.");

    var noSleep = new NoSleep();

    var obj = document.getElementById('map');
    obj.addEventListener('touchstart', function () {
      if (!no_sleep_enabled) {
        console.log("NoSleep Ativado :)");
        noSleep.enable(); // keep the screen on!
        no_sleep_enabled = true;
      }
    }, false);
  }
  else {
//    alert("Dispositivo Fixo.");
  }

  all_teams = [];
  all_geo_entities = [];

  // delay da inicialização do eventSource
  // delay atual - 10 segundos
  setTimeout(eventSourceSetup, 10000);

  sidebar = L.control.sidebar('sidebar', {position: 'right'}).addTo(map);
  cluster = L.markerClusterGroup();

  osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  osm = L.tileLayer(osmUrl, {maxZoom: 19});

  /* mapa principal */
  map = L.map("map", {
    zoom: 16,
//    center: [38.627881, -9.161007],
//    center: L.latLng(gon.current_lat, gon.current_lon),
    layers: [osm],
    zoomControl: true,
    attributionControl: false
  });

  user_centered_circle = L.circle(L.latLng(gon.current_lat, gon.current_lon), 500, {
    color: 'blue',
    fillOpacity: 0.2,
    weight: 0,
    clickable: false
  }).addTo(map);
  map.fitBounds(user_centered_circle);

  // ativa a geolocalização apenas se o browser a suportar
  if ("geolocation" in navigator) { /* geolocation is available */
    new L.control.locate({
      position: "topleft",
      layer: drawnItems,
      drawCircle: true,
      follow: false,
      setView: false,
      keepCurrentZoomLevel: true,
      stopFollowingOnDrag: false,
      remainActive: false,
      markerStyle: {
        weight: 1,
        opacity: 0.8,
        fillOpacity: 0.8
      },
      circleStyle: {
        weight: 1,
        clickable: false
      },
      icon: "fa fa-location-arrow",
      metric: true,
      strings: {
        title: "Clique aqui para ativar/desativar a geolocalização",
        popup: "A sua localização atual está dentro deste círculo com {distance} metros.",
        outsideMapBoundsMsg: "Parece que se encontra fora dos limites do mapa"
      },
      locateOptions: {
        maxZoom: 19,
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 15000,
        timeout: 1000
      }
    }).addTo(map);

    map.on('locationfound', function (e) {
      console.log("POSIÇÃO OBTIDA COM SUCESSO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
      console.log(e);

      var distance = -1, time_spanned = -1, curr_time, prev_time;
      if (typeof previous_user_location !== 'undefined') {
        distance = previous_user_location.position.distanceTo(e.latlng);
        curr_time = new Date();
        prev_time = previous_user_location.timestamp;

        // caso a diferença seja seja, passa a 1ms para evitar divisão por zero
        // resultado em ms, divisao por 1000 para converter para segundos
        time_spanned = (curr_time - prev_time) == 0 ? 1 : (curr_time - prev_time) / 1000;

        console.log("DIFERENÇA DO TIMESTAMP: " + time_spanned);
        console.log("DISTANCIA PARA MEDIÇÃO ANTERIOR: " + distance);
      }

      // envia a nova posição para o servidor caso seja a primeira vez,
      // a distancia para a posição anterior seja superior a 10 metros ou
      // a ultima medição tenha sido há mais de 10 segundos
      if ((distance == -1 || distance > 10) && (time_spanned == -1 || time_spanned > 10)) {
        console.log("POSIÇÃO A MAIS DE 10METROS E HÁ MAIS DE 10SEGUNDOS!!!!!!");

        // atualizam-se ja estas variaveis pois o retorno do ajax pode demorar e aí a posição era
        // atualizada várias vezes ao invés de apenas uma.
        previous_user_location = {position: e.latlng, timestamp: e.timestamp};

        $.ajax({
          type: "POST",
          url: "/update_location",
          data: {
            latitude: e.latlng.lat,
            longitude: e.latlng.lng,
            user_id: gon.user_id
          },
          success: function (result) {
            console.log(result);

//            var new_marker = L.marker(e.latlng, {icon: user_pos_icon});
//            cluster.addLayer(new_marker);
//            map.addLayer(cluster);

            var d = new Date();
            var time = d.toLocaleTimeString();

            var li = $('<li/>').addClass('collection-item');
            var span1 = $('<span/>').text("Coordenadas: [" + e.latlng.lat + "; " + e.latlng.lng + "]");
            var span2 = $('<span/>').text("Precisão da medição: " + e.accuracy + " metros");
            var span3 = $('<span/>').text("Data do sistema: " + time);

            li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
            $('#current_position_list').prepend(li);
          },
          error: function (err) {
            console.log(err);
          }
        });
//      map.setView(c_latlng, 16);
      }
//      setTimeout(map.locate(), 5000);
    });

  }
  else { /* geolocation IS NOT available */
    noty({
      text: 'Este browser não suporta geolocalização!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  }


  drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  /* controlo do zoom do mapa  */
  map.zoomControl.setPosition('topleft');

//  TODO: ADICIONAR O IF, ESTA COMENTADO APENAS PARA EFEITOS DE TESTE!
  // apenas cria os controlos para adicionar geo-entidades se não o perfil NÃO for 'Básico'
//  if (gon.user_profile !== "Basico") {
  // cria a barra de controlos para a criaçao de entidades
  L.drawLocal.draw.toolbar.buttons.polygon = 'Desenhar um polígono';
  L.drawLocal.draw.toolbar.buttons.polyline = 'Desenhar uma linha poligonal';
  L.drawLocal.draw.toolbar.buttons.marker = 'Desenhar um marcador';
  L.drawLocal.draw.toolbar.buttons.rectangle = 'Desenhar um rectângulo';
  L.drawLocal.draw.toolbar.buttons.circle = 'Desenhar um círculo';
  var drawControl = new L.Control.Draw({
    position: 'bottomleft',
    draw: {
      polygon: {
        title: 'Polígono',
        allowIntersection: true,
        drawError: {
          color: '#b00b00',
          timeout: 1000
        },
        shapeOptions: {
          color: '#bada55'
        },
        showArea: true
      },
      polyline: {
        metric: true
      },
      circle: {
        shapeOptions: {
          color: '#662d91'
        }
      }
    }
  });
  map.addControl(drawControl);
//  }

  // cria uma imagem com a inicial do nome do utilizador autenticado
  $('.profile_name').initial({
    name: 'Name', // Name of the user
    charCount: 1, // Number of characherts to be shown in the picture.
    textColor: '#ffffff', // Color of the text
    seed: 0, // randomize background color
    height: 40,
    width: 40,
    fontSize: 20,
    fontWeight: 400,
    fontFamily: 'Helvetica Neue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial, Lucida Grande, sans-serif',
    radius: 25
  });

  //altera o background da lista das equipas quando o utilizador faz hover com o rato
  $("div.collapsible-header")
      .mouseenter(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#eaeaea")
      })
      .mouseleave(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#fff")
      });

  //faz mais ou menos o mesmo mas quando o utilizador clica numa entrada da lista
  $("div.collapsible-header").click(function (div) {
    $("div.collapsible-header").css("background", "#fff");
    $("div.collapsible-header.active").css("background", "#eaeaea");
  });

  // inicializa as dropdowns que existem na pagina!
  $('select').material_select();

  map.spin(true, {
    lines: 15, // The number of lines to draw
    length: 0, // The length of each line
    width: 11, // The line thickness
    radius: 40, // The radius of the inner circle
    scale: 0.5, // Scales overall size of the spinner
    corners: 1, // Corner roundness (0..1)
    color: '#000', // #rgb or #rrggbb or array of colors
    opacity: 0, // Opacity of the lines
    rotate: 0, // The rotation offset
    direction: 1, // 1: clockwise, -1: counterclockwise
    speed: 1.2, // Rounds per second
    trail: 60, // Afterglow percentage
    fps: 30, // Frames per second when using setTimeout() as a fallback for CSS
    zIndex: 2e9, // The z-index (defaults to 2000000000)
    className: 'spinner', // The CSS class to assign to the spinner
    top: '50%', // Top position relative to parent
    left: '50%', // Left position relative to parent
    shadow: false, // Whether to render a shadow
    hwaccel: true, // Whether to use hardware acceleration
    position: 'absolute' // Element positioning
  });

  // ****************** CHAMADAS ASSINCRONAS PARA POPULAR O MAPA ******************
  // retorna todas as entidades que estao na BD
  var geo_entities = new L.GeoJSON.AJAX("/geo_entities/geo_entities_to_json.json", {
    pointToLayer: geoPointToLayer,
    onEachFeature: onEachGeoEntity
  });

  var teams_json = new L.GeoJSON.AJAX("/teams/teams_to_json.json", {
    pointToLayer: teamPointToLayer,
    onEachFeature: onEachTeam
  });

  // listener invocado quando a chamada ajax das entidades terminar!
  geo_entities.on('data:loaded', function () {
    console.log("vector com os indices das geo_entities: " + all_geo_entities);
    console.log("finish");

    cluster.addLayer(geo_entities);
    map.addLayer(cluster);

    geo_data_loaded++;
    if (geo_data_loaded == 2) {
      map.spin(false);
      geo_data_loaded = 0;
    }

    noty({
      text: 'Entidades geográficas carregadas com sucesso!', timeout: 3500,
      type: 'success', layout: 'bottomCenter'
    });

    // caso haja parametro, centra o mapa na entidade enviada
    var entity_id = parseInt(getURLParameter('entity_id'));

    if (!isNaN(entity_id))
      centerMapOnGeoEntity(entity_id);
  });

  geo_entities.on('data:error', function (err) {
    console.log(err);
    noty({
      text: 'Erro a carregar as entidades geográficas do servidor!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  });

  // listener invocado quando a chamada ajax das equipas terminar!
  teams_json.on('data:loaded', function () {
    console.log("vector com os indices das equipas!!!!!:");
    console.log(all_teams);
    console.log("finish");

    cluster.addLayer(teams_json);
    map.addLayer(cluster);

    geo_data_loaded++;
    if (geo_data_loaded == 2) {
      map.spin(false);
      geo_data_loaded = 0;
    }

    new_teams_count = 0;
    updated_teams_count = 0;
    removed_teams_count = 0;

    noty({text: 'Equipas carregadas com sucesso!', timeout: 3500, type: 'success', layout: 'bottomCenter'});
  });

  teams_json.on('data:error', function (err) {
    console.log(err);
    noty({
      text: 'Erro a carregar as equipas do servidor!', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
  });


// ****************** LISTENERS PARA A CRIA��O/EDI��O DE ENTIDADES ******************

  /* listener invocado quando � criada uma feature */
  map.on('draw:created', function (e) {
    console.log(e);
    e_type = e.layerType;
    e_layer = e.layer;
    e_num_points = 1;

    var select = $('#select_team_ids');

    // vai obter todas as equipas para popular a select box
    // assim garante-se que as equipas para selecionar estão sempre de acordo com a base de dados!
    $.ajax({
      type: "GET",
      url: "/teams/get_teams_by_profile",
      dataType: "json",
      success: function (res) {
        console.log(res.length);

        // primeiro removemos todas as entradas que la estao
        $(select).find('option').remove();

        if (res.length > 0) {
          // todas as equipas retornadas pelo servidor
          $.each(res, function (index, elem) {
            console.log(elem);
            var text = elem.name + " (ID: " + elem.id + ")";

            // append das equipas obtidas do servidor ao select
            select.append($("<option/>", {
              value: elem.id,
              text: text
            }));
          });
        }
        else {
          select.append($("<option/>", {
            value: "",
            text: "Não pertence a nenhuma equipa.",
            disabled: true
          }));
        }

        $('#select_team_ids_div label').addClass('active');
        console.log("final do each.");
      },
      error: function (res) {
        console.log("erro a popular as equipas: dropdown nova geo-entidade!!!");
        console.log(res);
      }
    });

    if (e_type === 'marker' || e_type === 'circle') {
      $("#e_area_div").prop('hidden', true);
      $("#e_length_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', true);

      if (e_type === 'circle') {
        e_radius = e_layer.getRadius();
        $('#e_type_div').removeClass('s4 s12').addClass('s6');
        $("#e_radius_div").prop('hidden', false);
        $('#e_radius').text(Math.round(e_radius));
        $('#e_type').text("Circulo");
      }
      else {
        e_radius = 0;
        $('#e_type_div').removeClass('s4 s6').addClass('s12');
        $("#e_radius_div").prop('hidden', true);
        $('#e_type').text("Marcador");
      }

      console.log(e_layer);
      e_coords = "POINT(" + e_layer.getLatLng().lng + " " + e_layer.getLatLng().lat + ")";
    }
    else if (e_type === 'polyline' || e_type === 'rectangle' || e_type === 'polygon') {
      e_radius = 0;
      e_num_points = e_layer.getLatLngs().length;

      $("#e_radius_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', false);
      $('#e_num_points').text(e_num_points);

      if (e_type === 'polyline') {
        e_coords = "LINESTRING(";

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_area_div").prop('hidden', true);
        $('#e_type').text("Linha Poligonal");
      }
      else {
        if (e_type === 'rectangle')
          $('#e_type').text("Rectangulo");
        else
          $('#e_type').text("Poligono");

        e_coords = "POLYGON((";
        e_area = L.GeometryUtil.geodesicArea(e_layer.getLatLngs());
        e_area = (Math.round(e_area) / 100000) + "";
        e_area = e_area.replace(".", ",");

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_length_div").prop('hidden', true);
        $("#e_area_div").prop('hidden', false);
        $('#e_area').text(e_area);
      }

      console.log(e_layer.getLatLngs());

      var temp_point = null;
      var c_arr = e_layer.getLatLngs();
      coords_to_display = "";
      e_length = 0;
      $.each(c_arr, function (i, curr_point) {
        coords_to_display += curr_point;
        if (e_type === 'polyline') {
          if (temp_point == null)
            temp_point = curr_point;
          else {
            e_length += temp_point.distanceTo(curr_point);
            temp_point = curr_point;
          }
        }
        e_coords += curr_point.lng + " " + curr_point.lat;
        if (i < c_arr.length - 1) {
          e_coords += ",";
          coords_to_display += "\n";
        }
      });

      $('#e_coords').val(coords_to_display);
      $('#e_coords').trigger('autoresize');
      $('#e_coords_div label').addClass('active');

      e_length = (Math.round(e_length) / 1000) + "";
      e_length = e_length.replace(".", ",");
      if (e_type === 'polyline') {
        e_coords += ")";
        $("#e_length_div").prop('hidden', false);
        $('#e_length').text(e_length);
      }
      else
        e_coords += "))";
    }

    // função executada quando a modal para inserir nova entidade é fechada
    var onModalHide = function () {
      is_modal_open = false;
    };

    $('#confirm_entity_creation').openModal({
      complete: onModalHide
    });

    is_modal_open = true;
  });

  /* listener invocado quando se edita uma feature */
  map.on('draw:edited', function (e) {
    noty({
      text: 'Funcionalidade não implementada.', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  });
});

// listeners para quando se carrega numa tecla predefinida.
$(document).keyup(function (e) {
  var elem, parent, tab_name, keyCode;
  keyCode = e.keyCode;

  // apenas queremos apanhar estas teclas quando a modal esta fechada, caso contrario
  // sempre que se introduzisse texto nas caixas de texto as abas laterais eram ativadas
//  if (!is_modal_open) {
//    // teclas que ativam a sidebar lateral
//    if (keyCode == 69 || keyCode == 80 || keyCode == 85 || keyCode == 87 || keyCode == 83) {
//      if (keyCode == 69) { // tecla 'E'
//        elem = $('#teams-tab-icon');
//        tab_name = 'teams';
//      }
//      else if (keyCode == 80) { // tecla 'P'
//        elem = $('#profile-tab-icon');
//        tab_name = 'profile';
//      }
//      else if (keyCode == 85) { // tecla 'U'
//        elem = $('#users-tab-icon');
//        tab_name = 'users';
//      }
//      else if (keyCode == 87) { // tecla 'W'
//        elem = $('#warnings-tab-icon');
//        tab_name = 'warnings';
//      }
//      else if (keyCode == 83) { // tecla 'S'
//        elem = $('#search-tab-icon');
//        tab_name = 'search';
//      }
//
//      parent = elem.parent();
//      if (parent.hasClass('active'))
//        sidebar.close(tab_name);
//      else
//        sidebar.open(tab_name);
//    }
//  }
});

/**
 * Transforma uma string com coordenadas num array
 *
 * @param coords a string com as coordenadas
 * @returns {Array} com 2 posições: 0 - lat; 1 - lon
 */
function parsePointCoordinates(coords) {
  var split_res = coords.split("(");
  var new_split_res = split_res[1].split(" ");

  var res = [];
  res.push(new_split_res[0]); //latitude
  res.push(new_split_res[1].split(")")[0]); //longitude

  return res;
}

/**
 * Função usada no mapa para apresentar as coordenadas de uma geo-entidade
 * através de uma modal no fundo da pagina
 *
 * @param coords
 * @returns {Array}
 */
function parseCoordinates(coords) {
  var i;
  var str_aux = "";
  var result = [];
  var temp_latlon;

  if (coords.indexOf("POINT") > -1) { // coordenadas de um ponto ou circulo
    str_aux = coords.split("(");
    str_aux = str_aux[1].split(")");
    str_aux = str_aux[0].split(" ");

    temp_latlon = L.latLng(str_aux[1], str_aux[0]);
    result.push(temp_latlon);
  }
  else if (coords.indexOf("POLYGON") > -1) { // coordenadas de um poligono
    str_aux = coords.split("((");
    str_aux = str_aux[1].split("))");
    str_aux = str_aux[0].split(", ");

    var t_coord;
    var length = str_aux.length;
    for (i = 0; i < length; i++) {
      t_coord = str_aux[i].split(" ");
      temp_latlon = L.latLng(t_coord[1], t_coord[0]);
      result.push(temp_latlon);
    }
  }
  else if (coords.indexOf("LINESTRING") > -1) { // coordenadas de uma linha poligonal
    str_aux = coords.split("(");
    str_aux = str_aux[1].split(")");
    str_aux = str_aux[0].split(", ");

    var t_coord;
    var length = str_aux.length;
    for (i = 0; i < length; i++) {
      t_coord = str_aux[i].split(" ");
      temp_latlon = L.latLng(t_coord[1], t_coord[0]);
      result.push(temp_latlon);
    }
  }

  return result;
}

/**
 * Função executada quando o utilizador encerra a modal e envia os dados da geoentidade
 * para o servidor. Faz um pedido ajax com a info e mostra uma notificação a informa o utilizador do resultado
 */
function insertGeoEntity() {
  console.log("inserir nova entidaade");

  var name = $('#e_name').val();
  var description = $('#e_description').val();

  var sel_team_ids = [];
  $('#select_team_ids :selected').each(function () {
    sel_team_ids.push(parseInt($(this).val()));
  });

  var errors = "";
  if (name.length === 0 || description.length === 0 || sel_team_ids.length === 0) {
    errors += (name.length === 0 ? "- Nome da entidade vazio;<br>" : "") +
        (description.length === 0 ? "- Descrição vazia;<br>" : "") +
        (sel_team_ids.length === 0 ? "- Nenhuma equipa selecionada;" : "");

    noty({
      text: 'Erro a criar a geo-entidade. Ocorreram os seguintes erros:<br><br>' + errors, timeout: 6000,
      type: 'error', layout: 'center', closeWith: ['button', 'click'], modal: true
    });
  }
  else {
    console.log("***** PROPRIEDADES DA ENTIDADE *****");
    console.log("nome: " + name);
    console.log("tipo: " + e_type);
    console.log("raio: " + e_radius);
    console.log("descriçao: " + description);
    console.log("coordenadas: " + e_coords);
    console.log("id da equipa a associar: " + sel_team_ids);
    console.log("************************************");

    $.ajax({
      type: "POST",
      url: "/geo_entities",
      dataType: "json",
      data: {
        geo_entity: {
          name: name,
          entity_type: e_type,
          radius: e_radius,
          description: description,
          latlon: e_coords,
          team_ids: sel_team_ids
        }
      },
      // adicionamos o id à lista de ids e criamos uma popup para essa entidade
      success: function (data) {
        console.log("MARCADOR ADICIONADO COM SUCESSO");
        console.log(data);

        // colocamos a flag a true para adicionar a entrada ao historico
        add_to_event_history = true;
        if (data.geometry.type === "Point") {
          var latlon = L.latLng(data.geometry.coordinates[1], data.geometry.coordinates[0]);
          geoPointToLayer(data, latlon);
        }

        onEachGeoEntity(data, e_layer);
        add_to_event_history = false;

        noty({
          text: 'Entidade geográfica introduzida com sucesso!', timeout: 3500,
          type: 'success', layout: 'bottomCenter'
        });

        drawnItems.addLayer(e_layer);
        map.addLayer(drawnItems);

        e_layer = null;

        // remove os valores do nome e descriçao que estavam no modal
        $('#e_name').val("");
        $('#e_description').val("");
        $("#select_team_ids option").prop("selected", false);

        $('#confirm_entity_creation').closeModal();
      },
      error: function (err) {
        if (err.status == 403) // o utilizador nao tem permissoes para remover geo-entidades
          noty({
            text: 'Não tem permissões para adicionar geo-entidades.', timeout: 4000,
            type: 'error', layout: 'bottomCenter'
          });
        else
          noty({
            text: 'Erro a introduzir a geo-entidade. Tente novamente mais tarde.', timeout: 4000,
            type: 'error', layout: 'bottomCenter'
          });

        console.log("erro a adicionar o marcador");
        console.log(err);
        e_layer = null;

        $('#confirm_entity_creation').closeModal();
      }
    });
  }
}

$('.stay-where-you-are').click(function (e) {
  // do something fancy
  return false; // prevent default click action from happening!
  //e.preventDefault(); // same thing as above
});

// recebe o json do servidor, processa-o e adiciona as entidades ao mapa
function addGeoEntityToMap(json) {
  console.log("UPDATES server sent event!!!!!!");

  var json_arr = JSON.parse(json);
  var new_layer; //, ent_type, latlon_arr = [];
  var new_features_count = 0;
  var removed_features_count = 0;
  var process_geojson = false;

  console.log(json_arr);

  // apenas uma entidade retornada pelo servidor
  if (json_arr.type == "Feature") {
    var geo_ent_in_map = geoEntityIsInMap(json_arr.properties.f_id);

    if (geo_ent_in_map == -1) { //geo-entidade nao esta no mapa
      if (json_arr.properties.updated_at !== null) { // nova geo-entidade para adicionar ao mapa
        console.log("apenas uma - GEO-ENTIDADE NAO EXISTE NO ARRAY");
        new_features_count++;
        process_geojson = true;
      }
    }
    else { // geo-entidade esta presente no mapa
      if (json_arr.properties.updated_at === null) { //removemos a geo-entidade do mapa - ja nao existe no servidor
        console.log("apenas uma - GEO-ENTIDADE É PARA REMOVER");

        removed_features_count++;
        geo_ents_to_remove.push(all_geo_entities[geo_ent_in_map]);
      }
    }

    // apenas processamos o json recebido pelo servidor se alguma das condições acima se verificar:
    // ou é uma nova geo-entidade (que não existe no mapa) e não é para remover;
    // ou é uma geo-entidade que existe no mapa e é para remover.
    if (process_geojson) {
      new_layer = L.geoJson(json_arr, {
        pointToLayer: geoPointToLayer,
        onEachFeature: onEachGeoEntity
      }).addTo(map);

      cluster.addLayer(new_layer);
      map.addLayer(cluster);
    }
  }

  // mais do que uma entidade retornada pelo servidor
  else if (json_arr.type == "FeatureCollection") {
    console.log("MAIS QUE UMA ENTIDADE, VAMOS ENTRAR NO FOR EACH!!!");

    // array GEOJSON que no final conterá todas as entidades que ainda nao estejam no mapa
    var final_json_arr = {
      "type": "FeatureCollection",
      "features": []
    };

    $.each(json_arr.features, function (index, elem) {
      var index_in_map = geoEntityIsInMap(elem.properties.f_id);

      console.log(all_geo_entities);
      console.log(elem.properties.f_id);
      console.log("f_id está contida no array?? " + index_in_map);

      if (index_in_map == -1) { //geo-entidade nao esta no mapa
        if (elem.properties.updated_at !== null) { // nova geo-entidade para adicionar ao mapa
          console.log("apenas uma - GEO-ENTIDADE NAO EXISTE NO ARRAY");

          final_json_arr.features.push(elem);
          new_features_count++;
          process_geojson = true;
        }
      }
      else { // geo-entidade esta presente no mapa
        if (elem.properties.updated_at === null) { //removemos a geo-entidade do mapa - ja nao existe no servidor
          console.log("apenas uma - GEO-ENTIDADE É PARA REMOVER");

          removed_features_count++;
          geo_ents_to_remove.push(all_geo_entities[index_in_map]);
        }
      }
    });

    console.log("NOVO JSON DAS ENTIDAADES:");
    console.log(final_json_arr);

    if (process_geojson) {
      new_layer = L.geoJson(final_json_arr, {
        pointToLayer: geoPointToLayer,
        onEachFeature: onEachGeoEntity
      }).addTo(map);

      cluster.addLayer(new_layer);
      map.addLayer(cluster);
    }
  }

  // criação de popup a indicar o numero de novas geo-entidades
  if (new_features_count == 1)
    noty({
      text: 'Uma nova geo-entidade foi adicionada ao mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  else if (new_features_count > 1)
    noty({
      text: 'Duas ou mais novas geo-entidades foram adicionadas ao mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });

  // criação de popup a indicar o numero de geo-entidades removidas
  if (removed_features_count == 1)
    noty({
      text: 'Uma geo-entidade foi removida do mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  else if (removed_features_count > 1)
    noty({
      text: 'Duas ou mais geo-entidades foram removidas do mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
}

/**
 * Metodo executado quando recebemos atualizações das equipa do servidor (SSE)
 *
 * @param json
 */
function addTeamToMap(json) {
  console.log("RECEBEMOS NOVA EQUIPA!!!!");

  var new_layer;
  var json_arr = JSON.parse(json);
  console.log(json_arr);

  new_layer = L.geoJson(json_arr, {
    pointToLayer: teamPointToLayer,
    onEachFeature: onEachTeam
  });

  if (new_teams_count == 1)
    noty({
      text: 'Uma nova equipa foi adicionada ao mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  else if (new_teams_count > 1)
    noty({
      text: 'Duas ou mais novas equipas foram adicionadas ao mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });

  if (updated_teams_count == 1)
    noty({
      text: 'Uma equipa foi atualizada!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  else if (updated_teams_count > 1)
    noty({
      text: 'Duas ou mais equipas foram atualizadas!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });

  if (removed_teams_count == 1)
    noty({
      text: 'Uma equipa foi removida do mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  else if (removed_teams_count > 1)
    noty({
      text: 'Duas ou mais equipas foram removidas do mapa!', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });

  new_teams_count = 0;
  updated_teams_count = 0;
  removed_teams_count = 0;

  cluster.addLayer(new_layer);
  map.addLayer(cluster);
}


// ****************** SSE STUFF :) ************************
function eventSourceSetup() {
  console.log("START DA CENA DO EVENT_SOURCE");

  // SSE stuff - atualização de informação
  if (!!window.EventSource)
    source = new EventSource("/entity_updates");
  else {
    // Result to xhr polling :(
  }

  // listener para a receção de updates de entidades geograficas
  source.addEventListener('entity_updates', function (e) {
    add_to_event_history = true;
    addGeoEntityToMap(e.data);
    add_to_event_history = false;
    cleanRemovedGeoEntities();
  }, false);

  // listener para a receçao de updates das equipas
  source.addEventListener('team_updates', function (e) {
    add_to_event_history = true;
    addTeamToMap(e.data);
    add_to_event_history = false;
    cleanRemovedTeams();
  }, false);
}

/**
 * remove do array de equipas todas as equipas que tenham sido eliminadas através dos updates via SSE
 */
function cleanRemovedTeams() {
  console.log("equipas para remover:");
  console.log(teams_to_remove);

  if (teams_to_remove.length > 0) {
    var temp_arr = [];
    $.each(teams_to_remove, function (index, elem) {
      cluster.removeLayer(elem.marker);
      map.removeLayer(elem.marker);
      temp_arr.push(elem.t_id);
    });

    all_teams = $.grep(all_teams, function (elem, index) {
      return $.inArray(elem.t_id, temp_arr) == -1;
    });

    teams_to_remove = [];
    console.log("acabei de limpar as equipas que ja tinham sido removidas!");
  }
}

/**
 * remove do array de geo-entidade todas as que tenham sido eliminadas através dos updates via SSE
 */
function cleanRemovedGeoEntities() {
  console.log("geo-entidades para remover:");
  console.log(geo_ents_to_remove);

  if (geo_ents_to_remove.length > 0) {
    var entry, temp_arr = [];
    $.each(geo_ents_to_remove, function (index, elem) {

      createNewHistoryEntry(object_type.geo_entity, elem.f_id, elem.f_name, new Date(), actions.remove,
          false, -1, -1);

      cluster.removeLayer(elem.layer);
      map.removeLayer(elem.layer);
      temp_arr.push(elem.f_id);
    });

    all_geo_entities = $.grep(all_geo_entities, function (elem, index) {
      return $.inArray(elem.f_id, temp_arr) == -1;
    });

    geo_ents_to_remove = [];
    console.log("acabei de limpar as geo-entidades que ja tinham sido removidas!");
  }
}

/**
 * Verifica se a equipa ja existe ou nao no mapa
 * Retorna -1 caso a equipa nao esteja no mapa
 * Retorna o indice caso a equipa ja exista no mapa
 */
function teamIsInMap(param_id) {
  var i;
  var length = all_teams.length;
  for (i = 0; i < length; i++) {
    if (all_teams[i].t_id === param_id) // a equipa existe
      return i;
  }
  return -1;
}

/**
 * Verifica se a entidade geografica ja existe ou nao no mapa
 * Retorna -1 caso nao esteja no mapa
 * Retorna o indice caso ja exista no mapa
 *
 * @param param_id é o id que a entidade possui na base de dados, e não o indice da mesma no array de entidades
 */
function geoEntityIsInMap(param_id) {
  var i;
  var length = all_geo_entities.length
  for (i = 0; i < length; i++) {
    if (all_geo_entities[i].f_id === param_id) // a entidade geografica existe
      return i;
  }
  return -1;
}

/**
 * apresenta as coordenadas da entidade selecionada num modal no fundo da pagina
 * recebe o id que a entidade tem na base de dados, que dps é transformado para a entrada no vector de entidades no mapa
 */
function showEntityCoordinates(entity_index) {
  var index_in_array = geoEntityIsInMap(entity_index);

  if (index_in_array > -1) {
    var geo_entity = all_geo_entities[index_in_array];
    var text_coords = "";

    // se tiver a propriedade
    var coords_arr = geo_entity.layer.hasOwnProperty("_latlng") ? [geo_entity.layer.getLatLng()] :
        geo_entity.layer.getLatLngs();

    $.each(coords_arr, function (index, elem) {
      text_coords += "(" + elem.lat + ", " + elem.lng + ")";
      if (index < coords_arr.length - 1)
        text_coords += ";    ";
    });

    var num_points = "";
    if (coords_arr.length == 1)
      num_points = "1 ponto";
    else
      num_points = coords_arr.length + " pontos";

    $("#modal_entity_type").text(geo_entity.type);
    $("#modal_num_points").text(num_points);
    $("#modal_coords").text(text_coords);
    $('#modal_entity_coordinates').openModal();
  }
  else
    noty({
      text: 'Erro a apresentar as coordenadas da entidade.', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
}

/**
 * função chamada quando o utilizador quer remover uma geo-entidade
 *
 * @param entity_index
 */
function removeGeoEntity(entity_index) {
  if (confirm("De certeza que pretende remover esta geo-entidade?\nEsta ação é irreversível!")) {
    var index_in_array = geoEntityIsInMap(entity_index);

    if (index_in_array > -1) {
      $.ajax({
        type: "DELETE",
        url: "/geo_entities/" + entity_index,
        dataType: "json",
        success: function () {
          // colocamos a entidade que o utilizador pretende remover neste array
          // por fim, chamamos o metodo que trata sua remoção do mapa e do array de entidades no mapa
          geo_ents_to_remove.push(all_geo_entities[index_in_array]);
          cleanRemovedGeoEntities();

          noty({
            text: 'Geo-entidade removida com sucesso.', timeout: 3500,
            type: 'success', layout: 'bottomCenter'
          });
        },
        error: function (res) {
          if (res.status == 403) // o utilizador nao tem permissoes para remover geo-entidades
            noty({
              text: 'Não tem permissões para remover geo-entidades.', timeout: 4000,
              type: 'error', layout: 'bottomCenter'
            });
          else
            noty({
              text: 'Ocorreu um erro a remover a entidade.\nTente novamente mais tarde.', timeout: 4000,
              type: 'error', layout: 'bottomCenter'
            });
        }
      });
    }
    else {
      noty({
        text: 'Ocorreu um erro a remover a entidade.\nExperimente recarregar a página.', timeout: 4000,
        type: 'error', layout: 'bottomCenter'
      });
    }
  }
}

// função executada pelo onEachFeature do metodo geoJSON das equipas
function onEachTeam(feature, layer) {
  // se a data de atualização for null é porque a equipa é para remover!!!!
  // caso contrario, associamos a popup como normal!
  if (feature.properties.updated_at !== null) {
    var popup = L.popup({maxWidth: 250});
    var content = '<span>Equipa número <b>' + feature.properties.f_id + '</b><br>' +
        '<b>Nome: </b>' + feature.properties.name + '<br>' +
        '<b>Líder: </b><a data-method="get" href="/users/' + feature.properties.leader_id + '">' +
        feature.properties.leader_name + '</a><br><b>Responsável pela posição: </b>' +
        '<a data-method="get" href="/users/' + feature.properties.location_user_id + '">' +
        feature.properties.location_user_name + '</a></span>';

    // so coloca as coordenadas de destaque na popup caso a equipa em questao esteja destacada
    if (feature.properties.highlight_coords !== null) {
      var parsed_highlight_coords = parsePointCoordinates(feature.properties.highlight_coords);
      content += '<p>Esta equipa está destacada para as coordenadas: <br>' +
          '<b>Latitude: </b>' + parsed_highlight_coords[1] + ';<br>' +
          '<b>Longitude: </b>' + parsed_highlight_coords[0] + '</p>'
    }
    else
      content += '<p>Esta equipa não está destacada para nenhum ponto. </p>';

    content += '<div class="center-align"><a data-method="get" href="/teams/' + feature.properties.f_id + '" ' +
        'class="waves-effect waves-light btn white-text" target="_blank" style="width: 100%;">Ir para equipa</a></div>';

    popup.setContent(content);
    layer.bindPopup(popup);
  }
}

/**
 * função executada pelo pointToLayer do metodo geoJSON das equipas
 * verifica se esta entidade ja existe no sistema
 * se sim, removemos para voltar a introduzir
 * caso a data de atualização for null, removemos a entidade
 *
 * @param feature
 * @param latlng
 */
function teamPointToLayer(feature, latlng) {
  console.log(feature);
  var index = teamIsInMap(feature.properties.f_id);
  var new_marker = L.marker(latlng, {icon: team_icon});
  var old_marker, team_to_push;
  var curr_action;

  team_to_push = new Team(feature.properties.f_id, feature.properties.name, feature.properties.location_user_id,
      feature.properties.location_user_name, feature.properties.updated_at, feature.properties.leader_name,
      feature.properties.leader_id, feature.properties.highlight_coords, new_marker);

  if (index == -1) {//equipa nao existe no mapa
    all_teams.push(team_to_push);

    curr_action = actions.create;
    new_teams_count++;

    console.log("NOVA EQUIPA RECEBIDA!!!");
  }
  else {
    // guardamos o antigo marcador da equipa para removermos e colocarmos o novo no mapa
    old_marker = all_teams[index].marker;
    all_teams[index] = team_to_push;

    cluster.removeLayer(old_marker);
    map.removeLayer(old_marker);

    curr_action = actions.update;
    updated_teams_count++;
  }

  if (feature.properties.updated_at === null) {
    teams_to_remove.push(team_to_push);

    curr_action = actions.remove;
    removed_teams_count++;
  }

  // updates periodicos enviados pelo servidor
  // apenas precisamos de guardar historico para updates do servidor ou ações do utilizador criadas durante a sessao
  if (add_to_event_history) {
    createNewHistoryEntry(object_type.team, feature.properties.f_id, feature.properties.name, new Date(),
        curr_action, false, -1, -1);
  }

  return new_marker;
}

// função executada pelo pointToLayer do metodo geoJSON das entidades geograficas
function geoPointToLayer(feature, latlng) {
  if (feature.properties.radius > 0)
    return L.circle(latlng, feature.properties.radius);
  else
    return L.marker(latlng);
}

// função executada pelo onEachFeature do metodo geoJSON das entidades geograficas
function onEachGeoEntity(feature, layer) {
  var new_entry, ent_type, temp_latlon, curr_action, radius = 0;
  var popup = L.popup({maxWidth: 250});

//  if (layer.hasOwnProperty('_latlng')) // só tem um par de coordenadas
//    temp_latlon = [layer.getLatLng()];
//  else if (layer.hasOwnProperty('_latlngs')) // tem mais do que um par de coordenadas
//    temp_latlon = layer.getLatLngs();

  // no caso de ser circulo, introduzimos o raio na popup
  if (feature.properties.radius > 0) {
    ent_type = geo_entity_types.circle;
    radius = feature.properties.radius;
  }
  else {
    if (feature.geometry.type === "LineString")
      ent_type = geo_entity_types.linestring;
    else if (feature.geometry.type === "Polygon")
      ent_type = geo_entity_types.polygon;
    else if (feature.geometry.type === "Point")
      ent_type = geo_entity_types.point;
  }

//  new_entry = {id: feature.properties.f_id, latlon: temp_latlon, type: ent_type, layer: layer};

  new_entry = new GeoEntity(feature.properties.f_id, feature.properties.name, feature.properties.description,
      feature.properties.username, feature.properties.user_id, feature.properties.radius, feature.properties.updated_at,
      feature.properties.entity_type, layer);

  all_geo_entities.push(new_entry);

  // esta entidade é para remover, nao precisamos de afectar a popup
  if (feature.properties.updated_at === null) {
    geo_ents_to_remove.push(new_entry);
    curr_action = actions.remove;
  }
  else {
    curr_action = actions.create;

    var popupContent = '<span>Entidade geográfica nº <b>' + feature.properties.f_id +
        '</b>, adicionada pelo utilizador <a data-method="get" href="/users/' + feature.properties.user_id + '">' +
        feature.properties.username + '</a>.</span><p><b>Tipo: </b>' + ent_type + '<br>' +
        (radius > 0 ? '<b>Raio: </b>' + radius + ' metros<br>' : '') + '<b>Nome: </b>' + feature.properties.name + '<br>' +
        '<b>Descrição: </b>' + feature.properties.description + '</p><div style="display: inline-block">' +
        '<a href="javascript:showEntityCoordinates(' + feature.properties.f_id + ');" ' +
        'class="geo-popup-btn waves-effect waves-light btn white-text">Ver coordenadas</a></div>' +
        '<div style="display: inline-block" class="right"><a href="javascript:removeGeoEntity(' +
        feature.properties.f_id + ');" class="geo-popup-btn red waves-effect waves-light btn white-text">' +
        '<i class="material-icons">delete</i></a></div>';

    popup.setContent(popupContent);
    layer.bindPopup(popup);
  }

  // updates periodicos enviados pelo servidor
  // apenas precisamos de guardar historico para updates do servidor ou ações do utilizador criadas durante a sessao
  if (add_to_event_history) {
    createNewHistoryEntry(object_type.geo_entity, feature.properties.f_id, feature.properties.name,
        new Date(), curr_action, false, feature.properties.username, feature.properties.user_id);
  }
}


/**
 * caso o URL contenha o campo 'entity_id', vamos verificar se a entidade existe no mapa
 * se sim, centramos o mapa nessa entidade.
 */
function centerMapOnGeoEntity(entity_id) {
  var indexOnArray = geoEntityIsInMap(entity_id);

  if (indexOnArray > -1) { // a entidade existe, centramos
    var entity = all_geo_entities[indexOnArray];
    var coords = (entity.layer.hasOwnProperty('_latlng') ? [entity.layer.getLatLng()] : entity.layer.getLatLngs());

    map.fitBounds(coords, {maxZoom: parseInt(curr_user_saved_prefs.max_zoom)});
    entity.layer.openPopup();

    noty({
      text: 'Mapa centrado na geo-entidade nº' + entity_id + '.', timeout: 3500,
      type: 'information', layout: 'bottomCenter'
    });
  }
  else
    noty({
      text: 'A geo-entidade nº' + entity_id + ' não existe no sistema.', timeout: 3500,
      type: 'error', layout: 'bottomCenter'
    });
}

// função que verifica se o parametro passado em argumento esta presente no URL
// se sim, devolve o valor correspondente a esse parametro
function getURLParameter(param) {
  var search_params = window.location.search.substring(1);
  var search_vars = search_params.split('&');
  var length = search_vars.length;

  for (var i = 0; i < length; i++) {
    var param_name = search_vars[i].split('=');

    if (param_name[0] == param)
      return param_name[1];
  }
}

/**
 * Le as preferencias do utilizador a partir do localStorage
 */
function checkUserPreferences() {
  var local_storage_user_prefs = JSON.parse(localStorage.getItem('user' + gon.user_id));
  console.log("preferencias do utilizador");
  console.log(local_storage_user_prefs);

  var show_navbar_checkbox = $('#homepage-toggle-navbar');

  // o utilizador ja iniciou sessão, vamos obter as suas preferencias
  if (local_storage_user_prefs !== null) {
    // le as entradas a partir do localStorage e coloca-as na timeline
    populateEventHistory(local_storage_user_prefs.events_history);

    // altera o nivel de zoom máximo para aquele que o utilizador definiu previamente
    $("#range_max_zoom").val(local_storage_user_prefs.max_zoom);
    curr_user_saved_prefs.max_zoom = local_storage_user_prefs.max_zoom;

    // altera o limite de entradas para o que o utilizador definiu anteriormente
    $('#entries_number').text(local_storage_user_prefs.history_entries_limit);
    $("#range_history_entry_max").val(local_storage_user_prefs.history_entries_limit);
    curr_user_saved_prefs.history_entries_limit = local_storage_user_prefs.history_entries_limit;

    // apresenta ou esconde a navbar consoante as preferencias do utilizador
    if (!local_storage_user_prefs.show_navbar) {
      toggleNavBar(false);
      show_navbar_checkbox.prop('checked', false);
    }
    else {
      toggleNavBar(true);
      show_navbar_checkbox.prop('checked', true);
    }
  }
  else {
    toggleNavBar(true);
    console.log(curr_user_saved_prefs);
  }
}

/**
 * mostra ou esconde a barra de navegação
 * grava no localStorage o estado atual da navbar
 * @param to_show
 */
function toggleNavBar(to_show) {
  var new_sidebar_height, new_top;
  var curr_window_height = window.innerHeight,
      curr_window_width = window.innerWidth,
      navbar_height = $('#frontpage-navbar').height(),
      new_map_height = window.innerHeight - navbar_height,
      sidebar_padding = 10;

  if (to_show) {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_top = navbar_height;
      new_sidebar_height = curr_window_height - navbar_height;
    }
    else {
      new_top = navbar_height + sidebar_padding;
      new_sidebar_height = curr_window_height - navbar_height - 2 * sidebar_padding;
    }

    $('#frontpage-navbar').slideDown({queue: false});
    $('#map').animate({'height': new_map_height, duration: 'slow', queue: false});
    $('#sidebar').animate({'top': new_top + 'px', 'height': new_sidebar_height + 'px', duration: 'slow', queue: false});
    curr_user_saved_prefs.show_navbar = true;
  }
  else {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_top = 0;
      new_sidebar_height = curr_window_height;
    }
    else {
      new_top = sidebar_padding;
      new_sidebar_height = curr_window_height - 2 * sidebar_padding;
    }

    $('#frontpage-navbar').slideUp({queue: false});
    $('#sidebar').animate({'top': new_top + 'px', 'height': new_sidebar_height + 'px', duration: 'slow', queue: false});
    $('#map').animate({'height': '100%', queue: false});
    curr_user_saved_prefs.show_navbar = false;
  }
  localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
}

// cria novos objectos HistoryEntry a partir do que foi lido do localStorage
function populateEventHistory(loaded_events) {
  console.log("vamos popular o historico do user");
  var arr = [], i, entry;
  var length = loaded_events.length;

  for (i = 0; i < length; i++) {
    entry = new HistoryEntry(loaded_events[i].obj_type, loaded_events[i].obj_id, loaded_events[i].title,
        loaded_events[i].timestamp, loaded_events[i].action, loaded_events[i].watched,
        loaded_events[i].username, loaded_events[i].user_id);
    prependHistoryDivEntry(entry);
    arr.push(entry);
  }

  curr_user_saved_prefs.events_history = arr;
}

// ajusta o tamanho do mapa, navbar e sidebar quando a janela é redimensionada
function onWindowResize(event) {
  var new_sidebar_top, new_sidebar_height;
  var curr_window_height = window.innerHeight,
      curr_window_width = window.innerWidth,
      navbar_height = $('#frontpage-navbar').height(),
      new_map_height = curr_window_height - navbar_height;

  if (curr_user_saved_prefs.show_navbar) {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_sidebar_top = 56;
      new_sidebar_height = curr_window_height - navbar_height;
    }
    else {
      new_sidebar_top = 74;
      new_sidebar_height = curr_window_height - navbar_height - 20;
      console.log("aqui aqui");
    }

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#map').css({height: new_map_height});

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#sidebar').css({height: new_sidebar_height, top: new_sidebar_top + 'px'});
  }
  else {
    if (curr_window_width <= SMARTHPHONE_MAX_WIDTH) {
      new_sidebar_top = 0;
      new_sidebar_height = curr_window_height;
    }
    else {
      new_sidebar_top = 10;
      new_sidebar_height = curr_window_height - 20;
      console.log("aqui aqui");
    }

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#map').css({height: '100%'});

    // reajusta a altura do mapa sempre que a altura da janela se altera
    $('#sidebar').css({height: new_sidebar_height, top: new_sidebar_top + 'px'});
  }
}

// recebe os parametros do novo evento, adiciona-o ao localStorage do utilizador atual
function createNewHistoryEntry(o_type, o_id, title, time, event, watch, u_name, u_id) {
  var h_entry = new HistoryEntry(o_type, o_id, title, time, event, watch, u_name, u_id);

  if (!containsHistoryEntry(h_entry)) {
    curr_user_saved_prefs.events_history.push(h_entry);
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));

    prependHistoryDivEntry(h_entry);
    console.log("esta entrada nao existe, espetamos a gaja no historico kkkkkk!");
  }
  else
    console.log("esta entrada ja existe, nao fazemos nada!");
}


function prependHistoryDivEntry(entry) {
  console.log("PREPEND DA CENA DO HISTORICO!!!");
  var icon, new_element, info_text, time_span_to_string;
  var who_did = ""; // apenas aplicavel às geo-entidades
  var icon_to_center = "";
  var when_was_updated = "";

  console.log(entry.watched);

  // no caso de ser entidade geografica, colocamos o utilizador que a adicionou/removeu
  if (entry.obj_type === object_type.geo_entity) {
    if (entry.user_id === gon.user_id) // foi o proprio utilizador a realizar a ação
      who_did = " por si";
    else if (entry.user_id > 0)
      who_did = " pelo utilizador " + entry.username;
  }

  if (entry.action === actions.create || entry.action === actions.update) {
    icon_to_center = '<a class="waves-effect waves-light btn-flat right" ' +
        'onclick="javascript:centerMapOnGeoEntity(' + entry.obj_id + ')"' +
        'style="padding: 8px; line-height: normal; top: -10px; height: 38px;">' +
        '<i style="line-height: 23px !important;" class="material-icons md-24">my_location</i></a>';

    if (entry.action === actions.create) {
      icon = 'add';
      info_text = 'adicionada ao mapa';
    }
    else if (entry.action === actions.update) {
      icon = 'edit';
      info_text = 'atualizada';
    }
  }
  else if (entry.action === actions.remove) {
    icon = 'delete';
    info_text = 'removida do sistema';
  }

  if (add_to_event_history)
    when_was_updated = "Agora mesmo";
  else {
    // a diferença entre duas datas é retornada em milisegundos
    // divide-se por 1000 para ficar com o valor em segundos
    var date_param = Math.round(Math.abs(new Date(entry.timestamp) - new Date()) / 1000);
    time_span_to_string = timeDiffToString(date_param);
    when_was_updated = "Há " + time_span_to_string;
  }

  new_element = '<div class="timeline-item">' +
      '<div class="timeline-icon valign-wrapper ' + (entry.watched ? "" : "new-entry-icon") + '">' +
      '<i class="timeline-custom-icon material-icons md-24">' + icon + '</i></div>' +
      '<div class="timeline-content z-depth-1 ' + (entry.watched ? "" : "new-entry-content") + '">' +
      '<h6 class="' + (entry.watched ? "" : "new-entry-header") + '" style="font-size: large;"><span>' +
      entry.obj_type + ' ' + entry.action + '</span>' + icon_to_center + '</h6><div style="margin-top: 5px;"><div>' +
      '<span class="timeline-timestamp" style="font-style: italic; font-size: 12px;">' + when_was_updated +
      '</span></div><div><p style="margin: 0;">A ' + entry.obj_type.toLowerCase() + ' ' +
      (entry.obj_type === object_type.team ? ('<b><a data-method="get" target="_blank" href="/teams/' +
      entry.obj_id + '">' + entry.title + '</a></b>') : 'com título <b>' + entry.title + '</b>') +
      ' foi ' + info_text + '<a data-method="get" target="_blank" href="/users/' + entry.user_id + '">' +
      who_did + '</a>.</p></div></div></div></div>';

  $('#timeline').prepend(new_element);

  if (!entry.watched) {
    var badge_icon = $('#history-tab-icon');
    var nr_of_pending_notifs = $(badge_icon).attr('data-badge'); // undefined se não houver nenhuma notificação

    nr_of_pending_notifs === undefined ? $(badge_icon).attr('data-badge', '1')
        : $(badge_icon).attr('data-badge', parseInt(nr_of_pending_notifs) + 1);
  }
}

/**
 * metodo que verifica se a entrada passada como parametro ja existe no array de entradas do utilizador
 * devolve 'true' caso a ação, o id e o tipo sejam iguais e a diferença entre as timestamps seja menor que 22 segundos
 * (o tempo que vai entre 2 updates automaticos do servidor!)
 * devolve 'false' caso alguma destas condições falhe.
 *
 * Exemplo1:
 * obj1 = {obj_type: "Equipa", obj_id: 17, timestamp: "2015-12-18T15:12:29.654Z", action: "atualizada"}
 * obj2 = {obj_type: "Equipa", obj_id: 17, timestamp: "2015-12-18T15:12:49.654Z", action: "atualizada"}
 * devolve 'true' pois todas as condições são verdadeiras - caso a timestamp tivesse mais 3 segundos
 * ja devolvia 'false' - podia tratar-se de outro update que não o mesmo
 */
function containsHistoryEntry(obj) {
  var i;
  var length = curr_user_saved_prefs.events_history.length;

  for (i = 0; i < length; i++) {
    if (curr_user_saved_prefs.events_history[i].equals(obj))
      return true;
  }
  return false;
}

/**
 * recebe como parametro os segundos que queremos tratar
 */
function timeDiffToString(seconds) {
  var days, hours, minutes, string_to_ret = "";

  days = Math.floor(seconds / 86400); // numero de dias
  seconds -= days * 86400;
  hours = Math.floor(seconds / 3600); // numero de horas inteiras
  seconds -= hours * 3600;
  minutes = Math.floor(seconds / 60); // numero de minutos que sobram
  seconds -= minutes * 60;

  if (days > 0)
    string_to_ret += days + (days == 1 ? " dia, " : " dias, ");
  if (hours > 0)
    string_to_ret += hours + (hours == 1 ? " hora, " : " horas, ");
  if (minutes > 0)
    string_to_ret += minutes + (minutes == 1 ? " minuto e " : " minutos e ");
  if (seconds > 0)
    string_to_ret += seconds + (seconds == 1 ? " segundo" : " segundos");

  return string_to_ret;
}

/**
 * Atualiza as timestamps das entradas do historico a cada x segundos
 * Por enquanto esse valor fica nos 30 segundos - 30k milissegundos
 */
function updateTimestamps() {
  console.log("ATUALIZAR AS TIMESTAMPS!!!!!");
  console.log(new Date());

  var dom_elem, t_stamp_span, date_param;
  var items = $('.timeline-item');
  var length = items.length - 1; //para evitar aceder a posições fora de alcance - famoso indexOutOfBounds kkkk

  $.each(curr_user_saved_prefs.events_history, function (index, elem) {
    dom_elem = $(items).get(length - index);
    t_stamp_span = $(dom_elem).find('.timeline-timestamp');

    date_param = Math.round(Math.abs(new Date(elem.timestamp) - new Date()) / 1000);
    $(t_stamp_span).text("Há " + timeDiffToString(date_param));
  });

  setTimeout(updateTimestamps, 30000);
}

/**
 * Limpa as entradas que estão atualmente no histórico da barra lateral
 * Remove ainda as mesmas entradas do localStorage
 */
function clearHistoyEntries() {
  if (confirm('Tem a certeza que pretende remover as entradas do histórico?\nEsta ação também remove todas as' +
          ' entradas que estão em cache.')) {
    $('.timeline-item').remove();
    curr_user_saved_prefs.events_history = [];
    localStorage.setItem('user' + gon.user_id, JSON.stringify(curr_user_saved_prefs));
  }
}

/**
 * Metodo que dada uma localização faz um pedido de geocode ao servidor
 * Recebe uma localização e devolve as coordenadas desse local
 * Por fim, centra o mapa nessas coordenadas
 */
function geocodeLocation() {
  var loc = $('#geocode_location').val();

  if (loc.length > 0) {
    $.ajax({
      type: "GET",
      url: "/geocode_location",
      data: {
        location: loc
      },
      success: function (result) {
        console.log(result);

        if (result.length > 0) {
          var coords = result[0].data.geometry.location;
          console.log(coords);
          map.setView(new L.LatLng(coords.lat, coords.lng), 16);

          noty({
            text: 'Geocoding efetuado com sucesso, mapa centrado em <b>' + result[0].data.formatted_address + '</b>.',
            timeout: 3500, type: 'success', layout: 'bottomCenter'
          });
        }
        else
          noty({
            text: 'Erro a efetuar o geocoding, tente pesquisar outro local.', timeout: 3500,
            type: 'error', layout: 'bottomCenter'
          });
      },
      error: function (err) {
        console.log(err);

        noty({
          text: 'Erro a efetuar o geocoding, tente pesquisar outro local.', timeout: 3500,
          type: 'error', layout: 'bottomCenter'
        });
      }
    });
  }
}