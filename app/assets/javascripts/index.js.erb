var map, osmUrl, osmAttrib, osm, sidebar, cluster;
var drawnItems;
var e_type, e_radius, e_coords, coords_to_display, e_length, e_area, e_layer, e_num_points;
var source;
var all_geo_ents_ids;
var all_teams_ids; // cada entrada é da forma {id: feature_id, marker: L.marker(L.latLng(lat, lng))}
var previous_user_location; // {timestamp: Date(), position: L.latLng(lat, lng)}
var no_sleep_enabled = false;

// var incrementada quando um dos conjuntos de dados é carregado - equipas e entidades
var geo_data_loaded = 0;

var team_icon = L.icon({
  iconUrl: '/assets/team_icon.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});

var user_pos_icon = L.icon({
  iconUrl: '/assets/user-64.png',
  iconSize: [38, 38], // size of the icon
  iconAnchor: [19, 30], // point of the icon which will correspond to marker's location
  popupAnchor: [-1, -30] // point from which the popup should open relative to the iconAnchor
});


$(document).ready(function () {

  // apenas permite numeros no campo do numero de telefone
  $(".numeric").numeric();

  // apenas ativa a cena do wake lock caso seja um dispositivo movel
  if (/Android|webOS|iPhone|iPad|iPod|BlackBerry|BB|PlayBook|IEMobile|Windows Phone|Kindle|Silk|Opera Mini/i.
      test(navigator.userAgent)) {
    // Take the user to a different screen here.
//    alert("Dispositivo Móvel.");

    var noSleep = new NoSleep();

    var obj = document.getElementById('map');
    obj.addEventListener('touchstart', function () {
      if (!no_sleep_enabled) {
        console.log("NoSleep Ativado :)");
        noSleep.enable(); // keep the screen on!
        no_sleep_enabled = true;
      }
    }, false);
  }
  else {
//    alert("Dispositivo Fixo.");
  }


  all_teams_ids = [];
  all_geo_ents_ids = [];

  // delay da inicialização do eventSource
  // delay atual - 10 segundos
  setTimeout(eventSourceSetup, 10000);

  sidebar = L.control.sidebar('sidebar', {position: 'right'}).addTo(map);
  cluster = L.markerClusterGroup();

  osmUrl = 'http://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
  osm = L.tileLayer(osmUrl, {maxZoom: 20});

  /* mapa principal */
  map = L.map("map", {
    zoom: 12,
    center: [38.627881, -9.161007],
    layers: [osm],
    zoomControl: true,
    attributionControl: false
  });


  // ativa a geolocalização apenas se o browser a suportar
  if ("geolocation" in navigator) { /* geolocation is available */
    new L.control.locate({
      position: "topleft",
      layer: drawnItems,
      drawCircle: true,
      follow: false,
      setView: false,
      keepCurrentZoomLevel: true,
      stopFollowingOnDrag: false,
      remainActive: false,
      markerStyle: {
        weight: 1,
        opacity: 0.8,
        fillOpacity: 0.8
      },
      circleStyle: {
        weight: 1,
        clickable: false
      },
      icon: "fa fa-map-marker",
      metric: true,
      strings: {
        title: "Clique aqui para ativar/desativar a geolocalização",
        popup: "A sua localização atual está dentro deste círculo com {distance} metros.",
        outsideMapBoundsMsg: "Parece que se encontra fora dos limites do mapa"
      },
      locateOptions: {
        maxZoom: 20,
        watch: true,
        enableHighAccuracy: true,
        maximumAge: 15000,
        timeout: 1000
      }
    }).addTo(map);

    map.on('locationfound', function (e) {
      console.log("POSIÇÃO OBTIDA COM SUCESSO!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!");
      console.log(e);

      var distance = -1, time_spanned = -1, curr_time, prev_time;
      if (typeof previous_user_location !== 'undefined') {
        distance = previous_user_location.position.distanceTo(e.latlng);
        curr_time = new Date();
        prev_time = previous_user_location.timestamp;

        // caso a diferença seja seja, passa a 1ms para evitar divisão por zero
        // resultado em ms, divisao por 1000 para converter para segundos
        time_spanned = (curr_time - prev_time) == 0 ? 1 : (curr_time - prev_time) / 1000;

        console.log("DIFERENÇA DO TIMESTAMP: " + time_spanned);
        console.log("DISTANCIA PARA MEDIÇÃO ANTERIOR: " + distance);
      }

      // envia a nova posição para o servidor caso seja a primeira vez,
      // a distancia para a posição anterior seja superior a 10 metros ou
      // a ultima medição tenha sido há mais de 10 segundos
      if ((distance == -1 || distance > 10) && (time_spanned == -1 || time_spanned > 10)) {
        console.log("POSIÇÃO A MAIS DE 10METROS E HÁ MAIS DE 10SEGUNDOS!!!!!!");

        // atualizam-se ja estas variaveis pois o retorno do ajax pode demorar e aí a posição era
        // atualizada várias vezes ao invés de apenas uma.
        previous_user_location = {position: e.latlng, timestamp: e.timestamp};

        $.ajax({
          type: "POST",
          url: "/update_location",
          data: {
            latitude: e.latlng.lat,
            longitude: e.latlng.lng,
            user_id: gon.user_id
          },
          success: function (result) {
            console.log(result);

//            var new_marker = L.marker(e.latlng, {icon: user_pos_icon});
//            cluster.addLayer(new_marker);
//            map.addLayer(cluster);

            var d = new Date();
            var time = d.toLocaleTimeString();

            var li = $('<li/>').addClass('collection-item');
            var span1 = $('<span/>').text("Coordenadas: [" + e.latlng.lat + "; " + e.latlng.lng + "]");
            var span2 = $('<span/>').text("Precisão da medição: " + e.accuracy + " metros");
            var span3 = $('<span/>').text("Data do sistema: " + time);

            li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
            $('#current_position_list').prepend(li);
          },
          error: function (err) {
            console.log(err);
          }
        });
//      map.setView(c_latlng, 16);
      }
//      setTimeout(map.locate(), 5000);
    });

  }
  else {
    /* geolocation IS NOT available */
    alert("Geolocalização não suportada.");
  }


  drawnItems = new L.FeatureGroup();
  map.addLayer(drawnItems);

  /* controlo do zoom do mapa  */
  map.zoomControl.setPosition('topleft');

  // cria a barra de controlos para a criaçao de entidades
  L.drawLocal.draw.toolbar.buttons.polygon = 'Desenhar um poligono';
  L.drawLocal.draw.toolbar.buttons.polyline = 'Desenhar uma linha poligonal';
  L.drawLocal.draw.toolbar.buttons.marker = 'Desenhar um marcador';
  L.drawLocal.draw.toolbar.buttons.rectangle = 'Desenhar um rectangulo';
  L.drawLocal.draw.toolbar.buttons.circle = 'Desenhar um circulo';
  var drawControl = new L.Control.Draw({
    position: 'bottomleft',
    draw: {
      polygon: {
        title: 'Pol�gono',
        allowIntersection: true,
        drawError: {
          color: '#b00b00',
          timeout: 1000
        },
        shapeOptions: {
          color: '#bada55'
        },
        showArea: true
      },
      polyline: {
        metric: false
      },
      circle: {
        shapeOptions: {
          color: '#662d91'
        }
      },
      //rectangle: false //� assim que se desativam op��es
    }
//    },
//    edit: {
//      featureGroup: drawnItems
//    }
  });
  map.addControl(drawControl);

  // cria uma imagem com a inicial do nome do utilizador autenticado
  $('.profile_name').initial({
    name: 'Name', // Name of the user
    charCount: 1, // Number of characherts to be shown in the picture.
    textColor: '#ffffff', // Color of the text
    seed: 0, // randomize background color
    height: 40,
    width: 40,
    fontSize: 20,
    fontWeight: 400,
    fontFamily: 'Helvetica Neue-Light,Helvetica Neue Light,Helvetica Neue,Helvetica, Arial, Lucida Grande, sans-serif',
    radius: 25
  });

  //altera o background da lista das equipas quando o utilizador faz hover com o rato
  $("#recent_teams_list div:first-child")
      .mouseenter(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#eaeaea")
      })
      .mouseleave(function () {
        if (!($(this).hasClass("active")))
          $(this).css("background", "#fff")
      });

  //faz mais ou menos o mesmo mas quando o utilizador clica numa entrada da lista
  $("div.collapsible-header").click(function (div) {
    $("div.collapsible-header").css("background", "#fff");
    $("div.collapsible-header.active").css("background", "#eaeaea");
  });

  // inicializa as dropdowns que existem na pagina!
  $('select').material_select();


  // ****************** CHAMADAS ASSINCRONAS PARA POPULAR O MAPA ******************

  map.spin(true, {
    lines: 15 // The number of lines to draw
    , length: 0 // The length of each line
    , width: 11 // The line thickness
    , radius: 40 // The radius of the inner circle
    , scale: 0.5 // Scales overall size of the spinner
    , corners: 1 // Corner roundness (0..1)
    , color: '#000' // #rgb or #rrggbb or array of colors
    , opacity: 0 // Opacity of the lines
    , rotate: 0 // The rotation offset
    , direction: 1 // 1: clockwise, -1: counterclockwise
    , speed: 1.2 // Rounds per second
    , trail: 60 // Afterglow percentage
    , fps: 20 // Frames per second when using setTimeout() as a fallback for CSS
    , zIndex: 2e9 // The z-index (defaults to 2000000000)
    , className: 'spinner' // The CSS class to assign to the spinner
    , top: '50%' // Top position relative to parent
    , left: '50%' // Left position relative to parent
    , shadow: false // Whether to render a shadow
    , hwaccel: true // Whether to use hardware acceleration
    , position: 'absolute' // Element positioning
  });


  // retorna todas as entidades que estao na BD
  var geo_entities = new L.GeoJSON.AJAX("/get_geo_entities.json", {
    pointToLayer: function (feature, latlng) {
      if (feature.properties.radius > 0)
        return L.circle(latlng, feature.properties.radius);
      else
        return L.marker(latlng);
    },
    onEachFeature: function (feature, layer) {
      layer.bindPopup('<p>' + feature.properties.name + '</p>' +
          '<p>' + feature.properties.description + '</p>');
      all_geo_ents_ids.push(feature.properties.f_id);
    }
  });

  var t_marker;
  var teams_json = new L.GeoJSON.AJAX("/teams/teams_to_json.json", {
    pointToLayer: function (feature, latlng) {
      t_marker = L.marker(latlng, {icon: team_icon});
      all_teams_ids.push({id: feature.properties.f_id, marker: t_marker});

      return t_marker;
    },
    onEachFeature: function (feature, layer) {
      layer.bindPopup('<p><b> Equipa número ' + feature.properties.f_id + '</b></p>' +
          '<span>Nome: <b>' + feature.properties.name + '</b><br>' +
          'Latitude: <b>' + feature.geometry.coordinates[1] + '</b>;<br>' +
          'Longitude: <b>' + feature.geometry.coordinates[0] + '</b></span>');
    }
  });

  // listener invocado quando a chamada ajax das entidades terminar!
  geo_entities.on('data:loaded', function () {
    console.log("vector com os indices das geo_entities: " + all_geo_ents_ids);
    console.log("finish");
    cluster.addLayer(geo_entities);
    map.addLayer(cluster);

    geo_data_loaded++;
    if(geo_data_loaded == 2)
      map.spin(false);
  });

  geo_entities.on('data:error', function (err) {
    console.log(err);
  });

  // listener invocado quando a chamada ajax das equipas terminar!
  teams_json.on('data:loaded', function () {
    console.log("vector com os indices das equipas!!!!!:");
    console.log(all_teams_ids);
    console.log("finish");
    cluster.addLayer(teams_json);
    map.addLayer(cluster);

    geo_data_loaded++;
    if(geo_data_loaded == 2)
      map.spin(false);
  });

  teams_json.on('data:error', function (err) {
    console.log(err);
  });


  // ****************** LISTENERS PARA A CRIA��O/EDI��O DE ENTIDADES ******************

  /* listener invocado quando � criada uma feature */
  map.on('draw:created', function (e) {
    console.log(e);
    e_type = e.layerType;
    e_layer = e.layer;
    e_num_points = 1;

    if (e_type === 'marker' || e_type === 'circle') {
      $("#e_area_div").prop('hidden', true);
      $("#e_length_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', true);

      if (e_type === 'circle') {
        e_radius = e_layer.getRadius();
        $('#e_type_div').removeClass('s4 s12').addClass('s6');
        $("#e_radius_div").prop('hidden', false);
        $('#e_radius').text(Math.round(e_radius));
        $('#e_type').text("Circulo");
      }
      else {
        e_radius = 0;
        $('#e_type_div').removeClass('s4 s6').addClass('s12');
        $("#e_radius_div").prop('hidden', true);
        $('#e_type').text("Marcador");
      }

      $('#e_coords').val(e_layer.getLatLng());
      $('#e_coords').trigger('autoresize');
      $('#e_coords_div label').addClass('active');

      console.log(e_layer);
      e_coords = "POINT(" + e_layer.getLatLng().lng + " " + e_layer.getLatLng().lat + ")";
    }
    else if (e_type === 'polyline' || e_type === 'rectangle' || e_type === 'polygon') {
      e_radius = 0;
      e_num_points = e_layer.getLatLngs().length;

      $("#e_radius_div").prop('hidden', true);
      $("#e_num_points_div").prop('hidden', false);
      $('#e_num_points').text(e_num_points);

      if (e_type === 'polyline') {
        e_coords = "LINESTRING(";

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_area_div").prop('hidden', true);
        $('#e_type').text("Linha Poligonal");
      }
      else {
        if (e_type === 'rectangle')
          $('#e_type').text("Rectangulo");
        else
          $('#e_type').text("Poligono");

        e_coords = "POLYGON((";
        e_area = L.GeometryUtil.geodesicArea(e_layer.getLatLngs());
        e_area = (Math.round(e_area) / 100000) + "";
        e_area = e_area.replace(".", ",");

        $('#e_type_div').removeClass('s6 s12').addClass('s4');
        $("#e_length_div").prop('hidden', true);
        $("#e_area_div").prop('hidden', false);
        $('#e_area').text(e_area);
      }

      console.log(e_layer.getLatLngs());

      var temp_point = null;
      var c_arr = e_layer.getLatLngs();
      coords_to_display = "";
      e_length = 0;
      $.each(c_arr, function (i, curr_point) {
        coords_to_display += curr_point;
        if (e_type === 'polyline') {
          if (temp_point == null)
            temp_point = curr_point;
          else {
            e_length += temp_point.distanceTo(curr_point);
            temp_point = curr_point;
          }
        }
        e_coords += curr_point.lng + " " + curr_point.lat;
        if (i < c_arr.length - 1) {
          e_coords += ",";
          coords_to_display += "\n";
        }
      });

      $('#e_coords').val(coords_to_display);
      $('#e_coords').trigger('autoresize');
      $('#e_coords_div label').addClass('active');

      e_length = (Math.round(e_length) / 1000) + "";
      e_length = e_length.replace(".", ",");
      if (e_type === 'polyline') {
        e_coords += ")";
        $("#e_length_div").prop('hidden', false);
        $('#e_length').text(e_length);
      }
      else
        e_coords += "))";
    }
    $('#confirm_entity_creation').openModal();
  });

  /* listener invocado quando se edita uma feature */
  //map.on('draw:edited', function (e) {
  //    var layers = e.layers;
  //    layers.eachLayer(function (layer) {
  //        //do whatever you want, most likely save back to db
  //    });
  //});
});

//$(document).keyup(function(e) {
//    //if (e.keyCode == 13) $('.save').click();     // enter
//    if (e.keyCode == 27) { // esc
//        if(modal_is_open) {
//            drawnItems.removeLayer(e_layer);
//            modal_is_open = false;
//        }
//    }
//});


//// o parametro "coords" � da forma -> "POINT(33.333 11.111)"
//// retorna um vector com 2 posi�oes, uma para cada coordenada
//function parsePointCoordinates(coords) {
//  var split_res = coords.split("(");
//  var new_split_res = split_res[1].split(" ");
//
//  var res = [];
//  res.push(new_split_res[0]); //latitude
//  res.push(new_split_res[1].split(")")[0]); //longitude
//
//  return res;
//}

// envia a entidade criada para a Base de Dados
function insertGeoEntity() {
  console.log("inserir nova entidaade");

  var name = $('#e_name').val();
  var description = $('#e_description').val();

  console.log("***** PROPRIEDADES DA ENTIDADE *****");
  console.log("nome: " + name);
  console.log("tipo: " + e_type);
  console.log("raio: " + e_radius);
  console.log("descriçao: " + description);
  console.log("coordenadas: " + e_coords);
  console.log("************************************");

  $.ajax({
    type: "POST",
    url: "/geo_entities",
    dataType: "json",
    data: {
      geo_entity: {
        name: name,
        entity_type: e_type,
        radius: e_radius,
        description: description,
        latlon: e_coords
      }
    },
    // adicionamos o id à lista de ids e criamos uma popup para essa entidade
    success: function (data) {
      console.log("MARCADOR ADICIONADO COM SUCESSO");
      console.log(data);
      all_geo_ents_ids.push(data.id);

      var popup = L.popup({
        maxWidth: 400
      });
      popup.setContent("<span>" + name + "</span><br><span>" + e_coords + "</span><br><span>" + description + "</span>");
      e_layer.bindPopup(popup);

      cluster.addLayer(e_layer);
      map.addLayer(cluster);

//      drawnItems.addLayer(e_layer);
//      map.addLayer(drawnItems);

      e_layer = null;
    },
    error: function (err) {
      console.log("erro a adicionar o marcador");
      console.log(err);
      e_layer = null;
    }
  });
}

$('.stay-where-you-are').click(function (e) {
  // do something fancy
  return false; // prevent default click action from happening!
  //e.preventDefault(); // same thing as above
});

// recebe o json do servidor, processa-o e adiciona as entidades ao mapa
function addGeoEntityToMap(json) {
  console.log("UPDATES server sent event!!!!!!");

  var new_layer;
  var json_arr = JSON.parse(json);

  // apenas uma entidade retornada pelo servidor
  if (json_arr.type == "Feature") {
    console.log(json_arr);

    // esta feature ainda nao existe no array!!
    if (all_geo_ents_ids.indexOf(json_arr.properties.f_id) == -1) {
      console.log("FEATURE FEATURE - ainda nao existe no array");

      var layer_to_add;
      // é um circulo, vamos desenhá-lo à mão
      if (json_arr.properties.radius > 0) {
        var latlon = L.latLng(json_arr.geometry.coordinates[1], json_arr.geometry.coordinates[0]);
        layer_to_add = L.circle(latlon, json_arr.properties.radius);
      }
      // não é circulo, adicionamos normalmente ao mapa
      else {
        new_layer = L.geoJson().addTo(map);
        new_layer.addData(json_arr);
        layer_to_add = new_layer;
      }

      cluster.addLayer(layer_to_add);
      map.addLayer(cluster);

      all_geo_ents_ids.push(json_arr.properties.f_id);
    }
  }
  // mais do que uma entidade retornada pelo servidor
  else if (json_arr.type == "FeatureCollection") {
    console.log("MAIS QUE UMA ENTIDADE, VAMOS ENTRAR NO FOR EACH!!!");

    // array GEOJSON que no final conterá todas as entidades que ainda nao estejam no mapa
    var final_json_arr = {
      "type": "FeatureCollection",
      "features": []
    };

    $.each(json_arr.features, function (key, val) {
      var f_id = val.properties.f_id;
      console.log(all_geo_ents_ids);
      console.log(f_id);
      console.log("f_id está contida no array?? " + (all_geo_ents_ids.indexOf(f_id) != -1));

      // esta feature ainda nao existe no array!!
      if (all_geo_ents_ids.indexOf(f_id) == -1) {

        // é um circulo, vamos desenhá-lo à mão
        if (val.properties.radius > 0) {
          var latlon = L.latLng(val.geometry.coordinates[1], val.geometry.coordinates[0]);
          layer_to_add = L.circle(latlon, val.properties.radius);

          cluster.addLayer(layer_to_add);
          map.addLayer(cluster);
        }
        // não é circulo, adicionamos normalmente ao mapa
        else
          final_json_arr.features.push(val);

        all_geo_ents_ids.push(f_id);
      }
    });

    new_layer = L.geoJson().addTo(map);
    new_layer.addData(final_json_arr);
    cluster.addLayer(new_layer);
    map.addLayer(cluster);
  }
}

function addTeamToMap(json) {
  console.log("RECEBEMOS NOVA EQUIPA!!!!");

  var new_layer, new_marker, old_marker, index;
  var json_arr = JSON.parse(json);
  console.log(json_arr);

  new_layer = L.geoJson(json_arr, {
    pointToLayer: function (feature, latlng) {
      // verifica se esta entidade ja existe no sistema
      // se sim, removemos para voltar a introduzir
      index = teamIsInMap(feature.properties.f_id);
      new_marker = L.marker(latlng, {icon: team_icon});

      if (index == -1) //equipa nao existe no mapa
        all_teams_ids.push({id: feature.properties.f_id, marker: new_marker});

      else {
        old_marker = all_teams_ids[index].marker;
        all_teams_ids[index].marker = new_marker;

        cluster.removeLayer(old_marker);
        map.removeLayer(old_marker);
      }

      return new_marker;
    }
  });

  cluster.addLayer(new_layer);
  map.addLayer(cluster);
}

// ****************** SSE STUFF :) ************************
function eventSourceSetup() {
  console.log("START DA CENA DO EVENT_SOURCE");

  // SSE stuff - atualização de informação
  if (!!window.EventSource)
    source = new EventSource("/entity_updates");
  else {
    // Result to xhr polling :(
  }

  // listener para a receção de updates de entidades geograficas
  source.addEventListener('entity_updates', function (e) {
    addGeoEntityToMap(e.data);
  }, false);

  // listener para a receçao de updates das equipas
  source.addEventListener('team_updates', function (e) {
    addTeamToMap(e.data);
  }, false);
}


// ****************** TESTE GEOLOCALIZAÇÃO ************************
//function getUserPositionGPS() {
//  map.findAccuratePosition({
//    maxWait: 12500, // defaults to 10000
//    desiredAccuracy: 20 // defaults to 20
//  });
//
//  setTimeout(getUserPositionGPS, 15000);
//}
//
//function onAccuratePositionProgress(e) {
//  console.log("A OBTER A POSIÇÃO!!");
//  console.log(e);
//}
//
//function onAccuratePositionFound(e) {
//  console.log("POSIÇÃO OBTIDA!!");
//  console.log(e);
////  map.setView(e.latlng, 16);
//  L.marker(e.latlng).addTo(map);
//
//  var d = new Date();
//  var time = d.toLocaleTimeString();
//
//  var li = $('<li/>').addClass('collection-item');
//  var span1 = $('<span/>').text("Coordenadas: [" + e.latlng.lat + "; " + e.latlng.lng + "]");
//  var span2 = $('<span/>').text("Precisão da medição: " + e.accuracy + " metros");
//  var span3 = $('<span/>').text("Data do sistema: " + time);
//
//  li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
//  $('#current_position_list').prepend(li);
//}
//
//function onAccuratePositionError(e) {
//  console.log("ERRO A OBTER A POSIÇÃO!!");
//  console.log(e)
//}


//function teste() {
//  navigator.wakeLock.request("display").then(
//      function successFunction() {
//        // success
//        console.log("foda-se sucesso1");
//      },
//      function errorFunction() {
//        // error
//        console.log("foda-se erro1");
//      }
//  );
////here system indicates CPU, GPU, radio, wifi etc.
//  navigator.wakeLock.request("system").then(
//      function successFunction() {
//        // success
//        console.log("foda-se sucesso1");
//      },
//      function errorFunction() {
//        // error
//        console.log("foda-se erro1");
//      }
//  );
//}


//function cenaGPS() {
//  var options = {
//    enableHighAccuracy: true,
//    timeout: 85000,
//    maximumAge: 10000
//  };
//
//  function onsuccess(pos) {
//    console.log(pos);
//    var c_latlng = L.latLng(pos.coords.latitude, pos.coords.longitude);
////    var c_text = "POINT(" + c_latlng.lng + " " + c_latlng.lat + ")";
//
//    console.log("POSIÇÃO OBTIDA!!");
//    console.log(c_latlng);
//
//    var positionDate = new Date(pos.timestamp);
//    var currentDate = new Date();
//    console.log(positionDate.toLocaleString(), currentDate.toLocaleString());
//
//    var distance = -1;
//    if (typeof current_user_location !== 'undefined')
//      distance = current_user_location.distanceTo(c_latlng);
//
//    console.log("DISTANCIA PARA MEDIÇÃO ANTERIOR: " + distance);
//
//    // envia a nova posição para o servidor caso seja a primeira vez ou
//    // a distancia para a posição anterior seja superior a 10 metros
//    if (distance == -1 || distance > 10) {
//      console.log("POSIÇÃO ATUAL A MAIS DE 10M DA ANTERIOR!");
//
//      $.ajax({
//        type: "POST",
//        url: "/update_location",
//        data: {
//          latitude: pos.coords.latitude,
//          longitude: pos.coords.longitude,
//          user_id: gon.user_id
//        },
//        success: function (result) {
//          console.log(result);
//
//          var new_marker = L.marker(c_latlng, {icon: user_pos_icon});
//          cluster.addLayer(new_marker);
//          map.addLayer(cluster);
//
//          var d = new Date();
//          var time = d.toLocaleTimeString();
//
//          var li = $('<li/>').addClass('collection-item');
//          var span1 = $('<span/>').text("Coordenadas: [" + pos.coords.latitude + "; " + pos.coords.longitude + "]");
//          var span2 = $('<span/>').text("Precisão da medição: " + pos.coords.accuracy + " metros");
//          var span3 = $('<span/>').text("Data do sistema: " + time);
//
//          li.append(span1).append('<br>').append(span2).append('<br>').append(span3);
//          $('#current_position_list').prepend(li);
//        },
//        error: function (err) {
//          console.log(err);
//        }
//      });
////      map.setView(c_latlng, 16);
//    }
//    current_user_location = c_latlng;
//  }
//
//  // PERMISSION_DENIED = 1;
//  // POSITION_UNAVAILABLE = 2;
//  // TIMEOUT = 3;
//  function onerror(err) {
//    console.warn('ERROR(' + err.code + '): ' + err.message);
//  }
//
//  navigator.geolocation.getCurrentPosition(onsuccess, onerror, options);
//  setTimeout(cenaGPS, 10000);
//}


/*
 * Verifica se a equipa ja existe ou nao no mapa
 * Retorna -1 caso a equipa nao esteja no mapa
 * Retorna o indice caso a equipa ja exista no mapa
 */
function teamIsInMap(param_id) {
  var i;
  for (i = 0; i < all_teams_ids.length; i++) {
    if (all_teams_ids[i].id === param_id) // a equipa existe
      return i;
  }
  return -1;
}